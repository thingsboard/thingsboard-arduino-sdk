<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Helper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.15.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Helper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Static helper class that includes some uniliterally used functionalities in multiple places, especially the ThingsBoardHttp and ThingsBoard implementations.  
 <a href="classHelper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Helper_8h_source.html">Helper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab542c171f938ac9de22e443281f43515"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab542c171f938ac9de22e443281f43515"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHelper.html#ab542c171f938ac9de22e443281f43515">detectSize</a> (<a class="el" href="classchar.html">char</a> const *format, Args const &amp;... args)</td></tr>
<tr class="memdesc:ab542c171f938ac9de22e443281f43515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total amount of bytes needed to store the formatted string that will be created if the given format string and the arguments are passed to snprintf.  <a href="classHelper.html#ab542c171f938ac9de22e443281f43515">More...</a><br /></td></tr>
<tr class="separator:ab542c171f938ac9de22e443281f43515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa75fe9eb55f2f5712da62b69f0d3ad"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHelper.html#aeaa75fe9eb55f2f5712da62b69f0d3ad">getOccurences</a> (<a class="el" href="classuint8__t.html">uint8_t</a> const *bytes, <a class="el" href="classchar.html">char</a> symbol, unsigned int length)</td></tr>
<tr class="memdesc:aeaa75fe9eb55f2f5712da62b69f0d3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of occurences of the given smybol in the given byte payload.  <a href="classHelper.html#aeaa75fe9eb55f2f5712da62b69f0d3ad">More...</a><br /></td></tr>
<tr class="separator:aeaa75fe9eb55f2f5712da62b69f0d3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0959c2381f03fd148926863b82a2f2e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHelper.html#ab0959c2381f03fd148926863b82a2f2e">stringIsNullorEmpty</a> (<a class="el" href="classchar.html">char</a> const *str)</td></tr>
<tr class="memdesc:ab0959c2381f03fd148926863b82a2f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter the given string is either a nullptr or is an empty string, meaning it only contains a null terminator and no other characters.  <a href="classHelper.html#ab0959c2381f03fd148926863b82a2f2e">More...</a><br /></td></tr>
<tr class="separator:ab0959c2381f03fd148926863b82a2f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298c3b0efb63d47927c8648a15b0742e"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHelper.html#a298c3b0efb63d47927c8648a15b0742e">parseRequestId</a> (<a class="el" href="classchar.html">char</a> const *base_topic, <a class="el" href="classchar.html">char</a> const *received_topic)</td></tr>
<tr class="memdesc:a298c3b0efb63d47927c8648a15b0742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the portion of the received topic after the base topic as an integer. Should contain the request id that the original request was sent with Is used to know which received response is connected to which inital request.  <a href="classHelper.html#a298c3b0efb63d47927c8648a15b0742e">More...</a><br /></td></tr>
<tr class="separator:a298c3b0efb63d47927c8648a15b0742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7363487e60e3d0491749e0f1e6eb8c63"><td class="memTemplParams" colspan="2">template&lt;typename TSource &gt; </td></tr>
<tr class="memitem:a7363487e60e3d0491749e0f1e6eb8c63"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHelper.html#a7363487e60e3d0491749e0f1e6eb8c63">Measure_Json</a> (TSource const &amp;source)</td></tr>
<tr class="memdesc:a7363487e60e3d0491749e0f1e6eb8c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total size of the string the serializeJson method would produce including the null end terminator. Be aware that null terminator will later not be serialied in the serializeJson() call, meaning the returned written amount of bytes is the return value of this method - 1. See <a href="https://arduinojson.org/v6/api/json/measurejson/">https://arduinojson.org/v6/api/json/measurejson/</a> for more information on the underlying method used.  <a href="classHelper.html#a7363487e60e3d0491749e0f1e6eb8c63">More...</a><br /></td></tr>
<tr class="separator:a7363487e60e3d0491749e0f1e6eb8c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7361b3d271e249d16e4e66dd319d6a0"><td class="memTemplParams" colspan="2">template&lt;typename DataContainer , typename InputIterator &gt; </td></tr>
<tr class="memitem:ab7361b3d271e249d16e4e66dd319d6a0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHelper.html#ab7361b3d271e249d16e4e66dd319d6a0">remove</a> (DataContainer &amp;container, InputIterator const &amp;iterator)</td></tr>
<tr class="memdesc:ab7361b3d271e249d16e4e66dd319d6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element with the given index, which allows to use data containers that do not have a random-access iterator. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.  <a href="classHelper.html#ab7361b3d271e249d16e4e66dd319d6a0">More...</a><br /></td></tr>
<tr class="separator:ab7361b3d271e249d16e4e66dd319d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1993376178c8ec2cca8be58f3a35b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a54b1993376178c8ec2cca8be58f3a35b"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHelper.html#a54b1993376178c8ec2cca8be58f3a35b">distance</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:a54b1993376178c8ec2cca8be58f3a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two iterators.  <a href="classHelper.html#a54b1993376178c8ec2cca8be58f3a35b">More...</a><br /></td></tr>
<tr class="separator:a54b1993376178c8ec2cca8be58f3a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Static helper class that includes some uniliterally used functionalities in multiple places, especially the ThingsBoardHttp and ThingsBoard implementations. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab542c171f938ac9de22e443281f43515" name="ab542c171f938ac9de22e443281f43515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab542c171f938ac9de22e443281f43515">&#9670;&#160;</a></span>detectSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Helper::detectSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total amount of bytes needed to store the formatted string that will be created if the given format string and the arguments are passed to snprintf. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the snprintf method, allowing any arbitrary amount of combinations without having to rely on va_list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Formatting message that the given arguments will be inserted into </td></tr>
    <tr><td class="paramname">...args</td><td>Arguments that will be forwarded into the snprintf method see <a href="https://cplusplus.com/reference/cstdio/snprintf/">https://cplusplus.com/reference/cstdio/snprintf/</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of bytes in characters, needed for the formatted string with the given arguments inserted, to be displayed completly </dd></dl>

</div>
</div>
<a id="a54b1993376178c8ec2cca8be58f3a35b" name="a54b1993376178c8ec2cca8be58f3a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1993376178c8ec2cca8be58f3a35b">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Helper::distance </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between two iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element in the data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the data container (last element + 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the two iterators </dd></dl>

</div>
</div>
<a id="aeaa75fe9eb55f2f5712da62b69f0d3ad" name="aeaa75fe9eb55f2f5712da62b69f0d3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa75fe9eb55f2f5712da62b69f0d3ad">&#9670;&#160;</a></span>getOccurences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Helper::getOccurences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a> const *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of occurences of the given smybol in the given byte payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Byte payload that we want to check the symbol for </td></tr>
    <tr><td class="paramname">symbol</td><td>Symbol we want to search for </td></tr>
    <tr><td class="paramname">length</td><td>Length of the byte payload, meaning if we reach the given length and have not found any occurence of the symbol we return 0. Ensure to never pass a length that is longer than the actualy payload, because this will cause this method to read outside of the bounds of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of occurences of the given symbol </dd></dl>

</div>
</div>
<a id="a7363487e60e3d0491749e0f1e6eb8c63" name="a7363487e60e3d0491749e0f1e6eb8c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7363487e60e3d0491749e0f1e6eb8c63">&#9670;&#160;</a></span>Measure_Json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Helper::Measure_Json </td>
          <td>(</td>
          <td class="paramtype">TSource const &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the total size of the string the serializeJson method would produce including the null end terminator. Be aware that null terminator will later not be serialied in the serializeJson() call, meaning the returned written amount of bytes is the return value of this method - 1. See <a href="https://arduinojson.org/v6/api/json/measurejson/">https://arduinojson.org/v6/api/json/measurejson/</a> for more information on the underlying method used. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSource</td><td>Source class that should be used to serialize the json that is sent to the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Data source containing our json key value pairs we want to measure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size required for the string that would be produced by serializeJson + 1 byte for the string null terminator </dd></dl>

</div>
</div>
<a id="a298c3b0efb63d47927c8648a15b0742e" name="a298c3b0efb63d47927c8648a15b0742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298c3b0efb63d47927c8648a15b0742e">&#9670;&#160;</a></span>parseRequestId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Helper::parseRequestId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>base_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>received_topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the portion of the received topic after the base topic as an integer. Should contain the request id that the original request was sent with Is used to know which received response is connected to which inital request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_topic</td><td>Base portion of the topic that does not contain any parameters (v1/devices/me/attributes/response/) </td></tr>
    <tr><td class="paramname">received_topic</td><td>Received topic that contains the base topic as well as the request id parameter (v1/devices/me/rpc/response/$request_id) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted integral request id if possible or 0 if parsing as an integer failed </dd></dl>

</div>
</div>
<a id="ab7361b3d271e249d16e4e66dd319d6a0" name="ab7361b3d271e249d16e4e66dd319d6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7361b3d271e249d16e4e66dd319d6a0">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataContainer , typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Helper::remove </td>
          <td>(</td>
          <td class="paramtype">DataContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element with the given index, which allows to use data containers that do not have a random-access iterator. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataContainer</td><td>Class which allows to pass any arbitrary data container that contains the erase() method </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Class that points to the iterator position that should be erased in the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Data container holding the elements we want to remove an element from </td></tr>
    <tr><td class="paramname">index</td><td>Iterator position we want to remove the element at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0959c2381f03fd148926863b82a2f2e" name="ab0959c2381f03fd148926863b82a2f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0959c2381f03fd148926863b82a2f2e">&#9670;&#160;</a></span>stringIsNullorEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Helper::stringIsNullorEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wheter the given string is either a nullptr or is an empty string, meaning it only contains a null terminator and no other characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String that we want to check for emptiness </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter the given string is a nullptr or empty </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="Helper_8h_source.html">Helper.h</a></li>
<li>src/<a class="el" href="Helper_8cpp.html">Helper.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
