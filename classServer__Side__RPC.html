<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Server_Side_RPC&lt; MaxSubscriptions, MaxRPC, Logger &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.15.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classServer__Side__RPC-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Server_Side_RPC&lt; MaxSubscriptions, MaxRPC, Logger &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Handles the internal implementation of the ThingsBoard server side RPC API. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information.  
 <a href="classServer__Side__RPC.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Server__Side__RPC_8h_source.html">Server_Side_RPC.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Server_Side_RPC&lt; MaxSubscriptions, MaxRPC, Logger &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classServer__Side__RPC__inherit__graph.svg" width="256" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Server_Side_RPC&lt; MaxSubscriptions, MaxRPC, Logger &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classServer__Side__RPC__coll__graph.svg" width="256" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a597b0ac1a59ce5284da01bdce4fce804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a597b0ac1a59ce5284da01bdce4fce804">Server_Side_RPC</a> ()=default</td></tr>
<tr class="memdesc:a597b0ac1a59ce5284da01bdce4fce804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classServer__Side__RPC.html#a597b0ac1a59ce5284da01bdce4fce804">More...</a><br /></td></tr>
<tr class="separator:a597b0ac1a59ce5284da01bdce4fce804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d04a332af770baa6f1c361e805d3b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab70d04a332af770baa6f1c361e805d3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#ab70d04a332af770baa6f1c361e805d3b">RPC_Subscribe</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:ab70d04a332af770baa6f1c361e805d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes multiple server side RPC callbacks, that will be called if a request from the server for the method with the given name is received. Can be called even if we are currently not connected to the cloud, this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on and that subscription is also done automatically by the library once the device has established a connection to the cloud. Therefore this method can simply be called once at startup before a connection has been established and will then automatically handle the subscription of the topic once the connection has been established. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information.  <a href="classServer__Side__RPC.html#ab70d04a332af770baa6f1c361e805d3b">More...</a><br /></td></tr>
<tr class="separator:ab70d04a332af770baa6f1c361e805d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663bd730494664609bf644eceda6ea4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a663bd730494664609bf644eceda6ea4f">RPC_Subscribe</a> (<a class="el" href="classRPC__Callback.html">RPC_Callback</a> const &amp;callback)</td></tr>
<tr class="memdesc:a663bd730494664609bf644eceda6ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe one server side RPC callback, that will be called if a request from the server for the method with the given name is received. Can be called even if we are currently not connected to the cloud, this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on and that subscription is also done automatically by the library once the device has established a connection to the cloud. Therefore this method can simply be called once at startup before a connection has been established and will then automatically handle the subscription of the topic once the connection has been established. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information.  <a href="classServer__Side__RPC.html#a663bd730494664609bf644eceda6ea4f">More...</a><br /></td></tr>
<tr class="separator:a663bd730494664609bf644eceda6ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af101311cb5936a7430c960ae1fa5fd33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#af101311cb5936a7430c960ae1fa5fd33">RPC_Unsubscribe</a> ()</td></tr>
<tr class="memdesc:af101311cb5936a7430c960ae1fa5fd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubcribes all server side RPC callbacks. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information.  <a href="classServer__Side__RPC.html#af101311cb5936a7430c960ae1fa5fd33">More...</a><br /></td></tr>
<tr class="separator:af101311cb5936a7430c960ae1fa5fd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf42c040a6474a00fbf98a9804b4c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="API__Process__Type_8h.html#ab34b5ae8501eb4438f2d57a4569d41f9">API_Process_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a99bf42c040a6474a00fbf98a9804b4c9">Get_Process_Type</a> () const override</td></tr>
<tr class="memdesc:a99bf42c040a6474a00fbf98a9804b4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the way the server response should be processed. Only ever uses one at the time, because the response is either unserialized data which we need to process as such (OTA Firmware Update) or actually JSON which needs to be serialized (everything else)  <a href="classServer__Side__RPC.html#a99bf42c040a6474a00fbf98a9804b4c9">More...</a><br /></td></tr>
<tr class="separator:a99bf42c040a6474a00fbf98a9804b4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad88c0ddefa37261aadb2bdc06e3142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a0ad88c0ddefa37261aadb2bdc06e3142">Process_Response</a> (<a class="el" href="classchar.html">char</a> const *topic, <a class="el" href="classuint8__t.html">uint8_t</a> *payload, unsigned int length) override</td></tr>
<tr class="memdesc:a0ad88c0ddefa37261aadb2bdc06e3142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process callback that will be called upon response arrival and is responsible for handling the payload before serialization and calling the appropriate previously subscribed callbacks.  <a href="classServer__Side__RPC.html#a0ad88c0ddefa37261aadb2bdc06e3142">More...</a><br /></td></tr>
<tr class="separator:a0ad88c0ddefa37261aadb2bdc06e3142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e60f28924ef37dd4e302bfdb71a291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a43e60f28924ef37dd4e302bfdb71a291">Process_Json_Response</a> (<a class="el" href="classchar.html">char</a> const *topic, JsonDocument const &amp;data) override</td></tr>
<tr class="memdesc:a43e60f28924ef37dd4e302bfdb71a291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process callback that will be called upon response arrival and is responsible for handling the alredy serialized payload and calling the appropriate previously subscribed callbacks.  <a href="classServer__Side__RPC.html#a43e60f28924ef37dd4e302bfdb71a291">More...</a><br /></td></tr>
<tr class="separator:a43e60f28924ef37dd4e302bfdb71a291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102a0dc05a6ebaa8337b0a4ea02c9f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#ad102a0dc05a6ebaa8337b0a4ea02c9f3">Compare_Response_Topic</a> (<a class="el" href="classchar.html">char</a> const *topic) const override</td></tr>
<tr class="memdesc:ad102a0dc05a6ebaa8337b0a4ea02c9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares received response topic and the topic this api implementation handles responses on, messages from all other topics are ignored and only messages from topics that match are handled. For the comparsion we either compare the full expected string with the null termination, if the response topic does not include additional parameters. Example being shared attribute update (v1/devices/me/attributes) or we compare only before the null termination for topics that include additional parameters in the response. Like for example the original request id in the response of the attribute request (v1/devices/me/attributes/response/1)  <a href="classServer__Side__RPC.html#ad102a0dc05a6ebaa8337b0a4ea02c9f3">More...</a><br /></td></tr>
<tr class="separator:ad102a0dc05a6ebaa8337b0a4ea02c9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51b52497e7407a88b6b7d5ecd9a3127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#ae51b52497e7407a88b6b7d5ecd9a3127">Unsubscribe</a> () override</td></tr>
<tr class="memdesc:ae51b52497e7407a88b6b7d5ecd9a3127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubcribes all callbacks, to clear up any ongoing subscriptions and stop receiving information over the previously subscribed topic.  <a href="classServer__Side__RPC.html#ae51b52497e7407a88b6b7d5ecd9a3127">More...</a><br /></td></tr>
<tr class="separator:ae51b52497e7407a88b6b7d5ecd9a3127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af689dbb5af93573434df3578725f24f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#af689dbb5af93573434df3578725f24f7">Resubscribe_Topic</a> () override</td></tr>
<tr class="memdesc:af689dbb5af93573434df3578725f24f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the call to let the API clear up any ongoing single-event subscriptions (<a class="el" href="classProvision.html" title="Handles the internal implementation of the ThingsBoard provision API. See https://thingsboard....">Provision</a>, Attribute Request, RPC Request) and simply resubscribes the topic for all permanent subscriptions (RPC, Shared Attribute Update)  <a href="classServer__Side__RPC.html#af689dbb5af93573434df3578725f24f7">More...</a><br /></td></tr>
<tr class="separator:af689dbb5af93573434df3578725f24f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea7e4c9e0d06a4ccd255e360d18d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#aebea7e4c9e0d06a4ccd255e360d18d9c">loop</a> () override</td></tr>
<tr class="memdesc:aebea7e4c9e0d06a4ccd255e360d18d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal loop method to update inernal timers for API calls that can timeout. Only exists on boards that can not use the ESP Timer, because that one uses the FreeRTOS timer in the background instead and therefore does not require calling a loop method.  <a href="classServer__Side__RPC.html#aebea7e4c9e0d06a4ccd255e360d18d9c">More...</a><br /></td></tr>
<tr class="separator:aebea7e4c9e0d06a4ccd255e360d18d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5de7557ced13da8582df1d1e74e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#aeec5de7557ced13da8582df1d1e74e1f">Initialize</a> () override</td></tr>
<tr class="memdesc:aeec5de7557ced13da8582df1d1e74e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows to construct internal objects, after the required callback member methods have been set already. Required for API Implementations that subscribe further API calls, because immediately calling in the constructor can lead, to attempted subscriptions before the m_subscribe_api_callback is actually subscribed. Therefore we have to call methods like that, in this method instead, because it ensures all member methods are instantiated already.  <a href="classServer__Side__RPC.html#aeec5de7557ced13da8582df1d1e74e1f">More...</a><br /></td></tr>
<tr class="separator:aeec5de7557ced13da8582df1d1e74e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676fc650b63d2ab322c53dd338c569e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServer__Side__RPC.html#a676fc650b63d2ab322c53dd338c569e8">Set_Client_Callbacks</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classIAPI__Implementation.html">IAPI_Implementation</a> &amp; &gt;::function subscribe_api_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, JsonDocument const &amp;, size_t const &amp; &gt;::function send_json_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, <a class="el" href="classchar.html">char</a> const *const &gt;::function send_json_string_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function subscribe_topic_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function unsubscribe_topic_callback, <a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function get_receive_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function get_send_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, uint16_t, uint16_t &gt;::function set_buffer_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; size_t * &gt;::function get_request_id_callback) override</td></tr>
<tr class="memdesc:a676fc650b63d2ab322c53dd338c569e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the underlying callbacks that are required for the different API Implementation to communicate with the cloud. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing.  <a href="classServer__Side__RPC.html#a676fc650b63d2ab322c53dd338c569e8">More...</a><br /></td></tr>
<tr class="separator:a676fc650b63d2ab322c53dd338c569e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a19f24964069b7d4dbba84969d557a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="API__Process__Type_8h.html#ab34b5ae8501eb4438f2d57a4569d41f9">API_Process_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#a3a19f24964069b7d4dbba84969d557a5">Get_Process_Type</a> () const =0</td></tr>
<tr class="memdesc:a3a19f24964069b7d4dbba84969d557a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the way the server response should be processed. Only ever uses one at the time, because the response is either unserialized data which we need to process as such (OTA Firmware Update) or actually JSON which needs to be serialized (everything else)  <a href="classIAPI__Implementation.html#a3a19f24964069b7d4dbba84969d557a5">More...</a><br /></td></tr>
<tr class="separator:a3a19f24964069b7d4dbba84969d557a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96aa3153cba283de80ba26b690e7204"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#ab96aa3153cba283de80ba26b690e7204">Process_Response</a> (<a class="el" href="classchar.html">char</a> const *topic, <a class="el" href="classuint8__t.html">uint8_t</a> *payload, unsigned int length)=0</td></tr>
<tr class="memdesc:ab96aa3153cba283de80ba26b690e7204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process callback that will be called upon response arrival and is responsible for handling the payload before serialization and calling the appropriate previously subscribed callbacks.  <a href="classIAPI__Implementation.html#ab96aa3153cba283de80ba26b690e7204">More...</a><br /></td></tr>
<tr class="separator:ab96aa3153cba283de80ba26b690e7204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b84ea47a091faceb0dabd092bdbeda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#a30b84ea47a091faceb0dabd092bdbeda">Process_Json_Response</a> (<a class="el" href="classchar.html">char</a> const *topic, JsonDocument const &amp;data)=0</td></tr>
<tr class="memdesc:a30b84ea47a091faceb0dabd092bdbeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process callback that will be called upon response arrival and is responsible for handling the alredy serialized payload and calling the appropriate previously subscribed callbacks.  <a href="classIAPI__Implementation.html#a30b84ea47a091faceb0dabd092bdbeda">More...</a><br /></td></tr>
<tr class="separator:a30b84ea47a091faceb0dabd092bdbeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701edf72b23aeeded67baa6a0b9df1e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#a701edf72b23aeeded67baa6a0b9df1e3">Compare_Response_Topic</a> (<a class="el" href="classchar.html">char</a> const *topic) const =0</td></tr>
<tr class="memdesc:a701edf72b23aeeded67baa6a0b9df1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares received response topic and the topic this api implementation handles responses on, messages from all other topics are ignored and only messages from topics that match are handled. For the comparsion we either compare the full expected string with the null termination, if the response topic does not include additional parameters. Example being shared attribute update (v1/devices/me/attributes) or we compare only before the null termination for topics that include additional parameters in the response. Like for example the original request id in the response of the attribute request (v1/devices/me/attributes/response/1)  <a href="classIAPI__Implementation.html#a701edf72b23aeeded67baa6a0b9df1e3">More...</a><br /></td></tr>
<tr class="separator:a701edf72b23aeeded67baa6a0b9df1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00a5bafbb22cdf836e98d47cfaedcc8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#ae00a5bafbb22cdf836e98d47cfaedcc8">Unsubscribe</a> ()=0</td></tr>
<tr class="memdesc:ae00a5bafbb22cdf836e98d47cfaedcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubcribes all callbacks, to clear up any ongoing subscriptions and stop receiving information over the previously subscribed topic.  <a href="classIAPI__Implementation.html#ae00a5bafbb22cdf836e98d47cfaedcc8">More...</a><br /></td></tr>
<tr class="separator:ae00a5bafbb22cdf836e98d47cfaedcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a1c749927d79f4350554f51c0334e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#ac8a1c749927d79f4350554f51c0334e9">Resubscribe_Topic</a> ()=0</td></tr>
<tr class="memdesc:ac8a1c749927d79f4350554f51c0334e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the call to let the API clear up any ongoing single-event subscriptions (<a class="el" href="classProvision.html" title="Handles the internal implementation of the ThingsBoard provision API. See https://thingsboard....">Provision</a>, Attribute Request, RPC Request) and simply resubscribes the topic for all permanent subscriptions (RPC, Shared Attribute Update)  <a href="classIAPI__Implementation.html#ac8a1c749927d79f4350554f51c0334e9">More...</a><br /></td></tr>
<tr class="separator:ac8a1c749927d79f4350554f51c0334e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6523f99171e91aebe69838bf2968808"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#ab6523f99171e91aebe69838bf2968808">loop</a> ()=0</td></tr>
<tr class="memdesc:ab6523f99171e91aebe69838bf2968808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal loop method to update inernal timers for API calls that can timeout. Only exists on boards that can not use the ESP Timer, because that one uses the FreeRTOS timer in the background instead and therefore does not require calling a loop method.  <a href="classIAPI__Implementation.html#ab6523f99171e91aebe69838bf2968808">More...</a><br /></td></tr>
<tr class="separator:ab6523f99171e91aebe69838bf2968808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f964e8d27dd510329d87526b5e5b3a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#a2f964e8d27dd510329d87526b5e5b3a8">Initialize</a> ()=0</td></tr>
<tr class="memdesc:a2f964e8d27dd510329d87526b5e5b3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows to construct internal objects, after the required callback member methods have been set already. Required for API Implementations that subscribe further API calls, because immediately calling in the constructor can lead, to attempted subscriptions before the m_subscribe_api_callback is actually subscribed. Therefore we have to call methods like that, in this method instead, because it ensures all member methods are instantiated already.  <a href="classIAPI__Implementation.html#a2f964e8d27dd510329d87526b5e5b3a8">More...</a><br /></td></tr>
<tr class="separator:a2f964e8d27dd510329d87526b5e5b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fd36659e104e7160881d1274d54d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIAPI__Implementation.html#aa62fd36659e104e7160881d1274d54d5">Set_Client_Callbacks</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classIAPI__Implementation.html">IAPI_Implementation</a> &amp; &gt;::function subscribe_api_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, JsonDocument const &amp;, size_t const &amp; &gt;::function send_json_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, <a class="el" href="classchar.html">char</a> const *const &gt;::function send_json_string_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function subscribe_topic_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function unsubscribe_topic_callback, <a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function get_receive_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function get_send_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; bool, uint16_t, uint16_t &gt;::function set_buffer_size_callback, <a class="el" href="classCallback.html">Callback</a>&lt; size_t * &gt;::function get_request_id_callback)=0</td></tr>
<tr class="memdesc:aa62fd36659e104e7160881d1274d54d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the underlying callbacks that are required for the different API Implementation to communicate with the cloud. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing.  <a href="classIAPI__Implementation.html#aa62fd36659e104e7160881d1274d54d5">More...</a><br /></td></tr>
<tr class="separator:aa62fd36659e104e7160881d1274d54d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger = DefaultLogger&gt;<br />
class Server_Side_RPC&lt; MaxSubscriptions, MaxRPC, Logger &gt;</div><p >Handles the internal implementation of the ThingsBoard server side RPC API. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Logger</td><td>Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = <a class="el" href="classDefaultLogger.html" title="Default logger class used by the ThingsBoard class to log messages into the console output.">DefaultLogger</a> </td></tr>
    <tr><td class="paramname">MaxSubscriptions</td><td>Maximum amount of simultaneous server side rpc subscriptions. Once the maximum amount has been reached it is not possible to increase the size, this is done because it allows to allcoate the memory on the stack instead of the heap, default = Default_Subscriptions_Amount (1) </td></tr>
    <tr><td class="paramname">MaxRPC</td><td>Maximum amount of key-value pairs that will ever be sent in the subscribed callback method of an <a class="el" href="classRPC__Callback.html" title="Server-side RPC callback wrapper, contains the needed configuration settings to create the request th...">RPC_Callback</a>, allows to use a StaticJsonDocument on the stack in the background. If we simply use .to&lt;JsonVariant&gt;(); on the received document and use .set() to change the internal value then the size requirements are 0. However if we attempt to send multiple key-value pairs, we have to adjust the size accordingly. See <a href="https://arduinojson.org/v6/assistant/">https://arduinojson.org/v6/assistant/</a> for more information on how to estimate the required size and divide the result by 16 to receive the required MaxRPC value, default = Default_RPC_Amount (0) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a597b0ac1a59ce5284da01bdce4fce804" name="a597b0ac1a59ce5284da01bdce4fce804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597b0ac1a59ce5284da01bdce4fce804">&#9670;&#160;</a></span>Server_Side_RPC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;<a class="el" href="classServer__Side__RPC.html">::Server_Side_RPC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad102a0dc05a6ebaa8337b0a4ea02c9f3" name="ad102a0dc05a6ebaa8337b0a4ea02c9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad102a0dc05a6ebaa8337b0a4ea02c9f3">&#9670;&#160;</a></span>Compare_Response_Topic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Compare_Response_Topic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares received response topic and the topic this api implementation handles responses on, messages from all other topics are ignored and only messages from topics that match are handled. For the comparsion we either compare the full expected string with the null termination, if the response topic does not include additional parameters. Example being shared attribute update (v1/devices/me/attributes) or we compare only before the null termination for topics that include additional parameters in the response. Like for example the original request id in the response of the attribute request (v1/devices/me/attributes/response/1) </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the received response topic matches the topic this api implementation handles responses on </dd></dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#a701edf72b23aeeded67baa6a0b9df1e3">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="a99bf42c040a6474a00fbf98a9804b4c9" name="a99bf42c040a6474a00fbf98a9804b4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf42c040a6474a00fbf98a9804b4c9">&#9670;&#160;</a></span>Get_Process_Type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="API__Process__Type_8h.html#ab34b5ae8501eb4438f2d57a4569d41f9">API_Process_Type</a> <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Get_Process_Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the way the server response should be processed. Only ever uses one at the time, because the response is either unserialized data which we need to process as such (OTA Firmware Update) or actually JSON which needs to be serialized (everything else) </p>
<dl class="section return"><dt>Returns</dt><dd>How the API implementation should be passed the response </dd></dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#a3a19f24964069b7d4dbba84969d557a5">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="aeec5de7557ced13da8582df1d1e74e1f" name="aeec5de7557ced13da8582df1d1e74e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec5de7557ced13da8582df1d1e74e1f">&#9670;&#160;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that allows to construct internal objects, after the required callback member methods have been set already. Required for API Implementations that subscribe further API calls, because immediately calling in the constructor can lead, to attempted subscriptions before the m_subscribe_api_callback is actually subscribed. Therefore we have to call methods like that, in this method instead, because it ensures all member methods are instantiated already. </p>

<p>Implements <a class="el" href="classIAPI__Implementation.html#a2f964e8d27dd510329d87526b5e5b3a8">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="aebea7e4c9e0d06a4ccd255e360d18d9c" name="aebea7e4c9e0d06a4ccd255e360d18d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebea7e4c9e0d06a4ccd255e360d18d9c">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal loop method to update inernal timers for API calls that can timeout. Only exists on boards that can not use the ESP Timer, because that one uses the FreeRTOS timer in the background instead and therefore does not require calling a loop method. </p>

<p>Implements <a class="el" href="classIAPI__Implementation.html#ab6523f99171e91aebe69838bf2968808">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="a43e60f28924ef37dd4e302bfdb71a291" name="a43e60f28924ef37dd4e302bfdb71a291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e60f28924ef37dd4e302bfdb71a291">&#9670;&#160;</a></span>Process_Json_Response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Process_Json_Response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonDocument const &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process callback that will be called upon response arrival and is responsible for handling the alredy serialized payload and calling the appropriate previously subscribed callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Previously subscribed topic, we got the response over </td></tr>
    <tr><td class="paramname">data</td><td>Payload sent by the server over our given topic, that contains our key value pairs </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#a30b84ea47a091faceb0dabd092bdbeda">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="a0ad88c0ddefa37261aadb2bdc06e3142" name="a0ad88c0ddefa37261aadb2bdc06e3142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad88c0ddefa37261aadb2bdc06e3142">&#9670;&#160;</a></span>Process_Response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Process_Response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process callback that will be called upon response arrival and is responsible for handling the payload before serialization and calling the appropriate previously subscribed callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Previously subscribed topic, we got the response over </td></tr>
    <tr><td class="paramname">payload</td><td>Payload that was sent over the cloud and received over the given topic </td></tr>
    <tr><td class="paramname">length</td><td>Total length of the received payload </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#ab96aa3153cba283de80ba26b690e7204">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="af689dbb5af93573434df3578725f24f7" name="af689dbb5af93573434df3578725f24f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af689dbb5af93573434df3578725f24f7">&#9670;&#160;</a></span>Resubscribe_Topic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Resubscribe_Topic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards the call to let the API clear up any ongoing single-event subscriptions (<a class="el" href="classProvision.html" title="Handles the internal implementation of the ThingsBoard provision API. See https://thingsboard....">Provision</a>, Attribute Request, RPC Request) and simply resubscribes the topic for all permanent subscriptions (RPC, Shared Attribute Update) </p>
<dl class="section return"><dt>Returns</dt><dd>Whether resubscribing was successfull or not </dd></dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#ac8a1c749927d79f4350554f51c0334e9">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="ab70d04a332af770baa6f1c361e805d3b" name="ab70d04a332af770baa6f1c361e805d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70d04a332af770baa6f1c361e805d3b">&#9670;&#160;</a></span>RPC_Subscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::RPC_Subscribe </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes multiple server side RPC callbacks, that will be called if a request from the server for the method with the given name is received. Can be called even if we are currently not connected to the cloud, this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on and that subscription is also done automatically by the library once the device has established a connection to the cloud. Therefore this method can simply be called once at startup before a connection has been established and will then automatically handle the subscription of the topic once the connection has been established. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element in the data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the end of the data container (last element + 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether subscribing the given callbacks was successful or not </dd></dl>

</div>
</div>
<a id="a663bd730494664609bf644eceda6ea4f" name="a663bd730494664609bf644eceda6ea4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663bd730494664609bf644eceda6ea4f">&#9670;&#160;</a></span>RPC_Subscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::RPC_Subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRPC__Callback.html">RPC_Callback</a> const &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe one server side RPC callback, that will be called if a request from the server for the method with the given name is received. Can be called even if we are currently not connected to the cloud, this is the case because the only interaction that requires an active connection is the subscription of the topic that we receive the response on and that subscription is also done automatically by the library once the device has established a connection to the cloud. Therefore this method can simply be called once at startup before a connection has been established and will then automatically handle the subscription of the topic once the connection has been established. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> method that will be called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether subscribing the given callback was successful or not </dd></dl>

</div>
</div>
<a id="af101311cb5936a7430c960ae1fa5fd33" name="af101311cb5936a7430c960ae1fa5fd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af101311cb5936a7430c960ae1fa5fd33">&#9670;&#160;</a></span>RPC_Unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::RPC_Unsubscribe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubcribes all server side RPC callbacks. See <a href="https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc">https://thingsboard.io/docs/user-guide/rpc/#server-side-rpc</a> for more information. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether unsubcribing all the previously subscribed callbacks and from the rpc topic, was successful or not </dd></dl>

</div>
</div>
<a id="a676fc650b63d2ab322c53dd338c569e8" name="a676fc650b63d2ab322c53dd338c569e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676fc650b63d2ab322c53dd338c569e8">&#9670;&#160;</a></span>Set_Client_Callbacks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Set_Client_Callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classIAPI__Implementation.html">IAPI_Implementation</a> &amp; &gt;::function&#160;</td>
          <td class="paramname"><em>subscribe_api_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, JsonDocument const &amp;, size_t const &amp; &gt;::function&#160;</td>
          <td class="paramname"><em>send_json_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const, <a class="el" href="classchar.html">char</a> const *const &gt;::function&#160;</td>
          <td class="paramname"><em>send_json_string_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function&#160;</td>
          <td class="paramname"><em>subscribe_topic_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; bool, <a class="el" href="classchar.html">char</a> const *const &gt;::function&#160;</td>
          <td class="paramname"><em>unsubscribe_topic_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function&#160;</td>
          <td class="paramname"><em>get_receive_size_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; uint16_t &gt;::function&#160;</td>
          <td class="paramname"><em>get_send_size_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; bool, uint16_t, uint16_t &gt;::function&#160;</td>
          <td class="paramname"><em>set_buffer_size_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; size_t * &gt;::function&#160;</td>
          <td class="paramname"><em>get_request_id_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the underlying callbacks that are required for the different API Implementation to communicate with the cloud. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscribe_api_callback</td><td>Method which allows to subscribe additional API endpoints, points to Subscribe_API_Implementation per default </td></tr>
    <tr><td class="paramname">send_json_callback</td><td>Method which allows to send arbitrary JSON payload, points to Send_Json per default </td></tr>
    <tr><td class="paramname">send_json_string_callback</td><td>Method which allows to send arbitrary JSON string payload, points to Send_Json_String per default </td></tr>
    <tr><td class="paramname">subscribe_topic_callback</td><td>Method which allows to subscribe to arbitrary topics, points to m_client.subscribe per default </td></tr>
    <tr><td class="paramname">unsubscribe_topic_callback</td><td>Method which allows to unsubscribe from arbitrary topics, points to m_client.unsubscribe per default </td></tr>
    <tr><td class="paramname">get_receive_size_callback</td><td>Method which allows to get the current underlying receive size of the buffer, points to m_client.get_receive_buffer_size per default </td></tr>
    <tr><td class="paramname">get_send_size_callback</td><td>Method which allows to get the current underlying send size of the buffer, points to m_client.get_send_buffer_size per default </td></tr>
    <tr><td class="paramname">set_buffer_size_callback</td><td>Method which allows to set the current underlying size of the buffer, points to m_client.set_buffer_size per default </td></tr>
    <tr><td class="paramname">get_request_id_callback</td><td>Method which allows to get the current request id as a mutable reference, points to getRequestID per default </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#aa62fd36659e104e7160881d1274d54d5">IAPI_Implementation</a>.</p>

</div>
</div>
<a id="ae51b52497e7407a88b6b7d5ecd9a3127" name="ae51b52497e7407a88b6b7d5ecd9a3127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51b52497e7407a88b6b7d5ecd9a3127">&#9670;&#160;</a></span>Unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxSubscriptions = 1, size_t MaxRPC = 0, typename Logger  = DefaultLogger&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classServer__Side__RPC.html">Server_Side_RPC</a>&lt; MaxSubscriptions, MaxRPC, Logger &gt;::Unsubscribe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubcribes all callbacks, to clear up any ongoing subscriptions and stop receiving information over the previously subscribed topic. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether unsubcribing all the previously subscribed callbacks and from the previously subscribed topic, was successful or not </dd></dl>

<p>Implements <a class="el" href="classIAPI__Implementation.html#ae00a5bafbb22cdf836e98d47cfaedcc8">IAPI_Implementation</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Server__Side__RPC_8h_source.html">Server_Side_RPC.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
