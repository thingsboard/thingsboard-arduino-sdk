<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Attribute_Request_Callback&lt; MaxAttributes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.15.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAttribute__Request__Callback-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Attribute_Request_Callback&lt; MaxAttributes &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Client-side or shared attributes request callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Which attribute scope will be requested from either client-side or shared, is decided depending on which method the class instance is passed to as an argument. If that method is the Client_Attributes_Request() then the passed attributes are requested and if they exist are received from the client scope, but if that method is the Shared_Attributes_Request() then the passed attributes are requested and if they exist are received from the shared scope instead. To achieve that some internal member variables get set automatically by those methods, the first one being a string to differentiate which attribute scope was requested and the second being the id of the mqtt request, where the response by the server will use the same id, which makes it easy to know which method intially requested the data and should now receive it. Documentation about the specific use of Requesting client-side or shared scope atrributes in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server</a>.  
 <a href="classAttribute__Request__Callback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Attribute__Request__Callback_8h_source.html">Attribute_Request_Callback.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Attribute_Request_Callback&lt; MaxAttributes &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAttribute__Request__Callback__inherit__graph.svg" width="467" height="346"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Attribute_Request_Callback&lt; MaxAttributes &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAttribute__Request__Callback__coll__graph.svg" width="248" height="258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54f31ad9b6704885302369b8ae615f86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a54f31ad9b6704885302369b8ae615f86">Attribute_Request_Callback</a> ()=default</td></tr>
<tr class="memdesc:a54f31ad9b6704885302369b8ae615f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classAttribute__Request__Callback.html#a54f31ad9b6704885302369b8ae615f86">More...</a><br /></td></tr>
<tr class="separator:a54f31ad9b6704885302369b8ae615f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98f2814c55d036de48c2e79e9fd0b1a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac98f2814c55d036de48c2e79e9fd0b1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#ac98f2814c55d036de48c2e79e9fd0b1a">Attribute_Request_Callback</a> (<a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">function</a> callback, <a class="el" href="classuint64__t.html">uint64_t</a> const &amp;timeout_microseconds=0U, <a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">Callback_Watchdog::function</a> timeout_callback=nullptr, Args const &amp;... args)</td></tr>
<tr class="memdesc:ac98f2814c55d036de48c2e79e9fd0b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callback, will be called upon client-side or shared attribute request arrival where the given multiple requested client-side or shared attributes were sent by the cloud and received by the client. Directly forwards the given arguments to the overloaded vector constructor, meaning all combinatons of arguments that would initalize a vector can be used to call this constructor. See possible vector constructors <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passed parameters. The possibilites mainly consist out of the fill constructor, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range constructor where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy constructor where we pass a vector and the values of that vector will be copied into our buffer.  <a href="classAttribute__Request__Callback.html#ac98f2814c55d036de48c2e79e9fd0b1a">More...</a><br /></td></tr>
<tr class="separator:ac98f2814c55d036de48c2e79e9fd0b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5290f1d8b4228feab52a6f08ba862b"><td class="memItemLeft" align="right" valign="top">size_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a5e5290f1d8b4228feab52a6f08ba862b">Get_Request_ID</a> () const</td></tr>
<tr class="memdesc:a5e5290f1d8b4228feab52a6f08ba862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes.  <a href="classAttribute__Request__Callback.html#a5e5290f1d8b4228feab52a6f08ba862b">More...</a><br /></td></tr>
<tr class="separator:a5e5290f1d8b4228feab52a6f08ba862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e826dfb081804c81e101c00d1eabab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a21e826dfb081804c81e101c00d1eabab">Set_Request_ID</a> (size_t const &amp;request_id)</td></tr>
<tr class="memdesc:a21e826dfb081804c81e101c00d1eabab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because only the ThingsBoard class knows the current request id that this callback will be attached too.  <a href="classAttribute__Request__Callback.html#a21e826dfb081804c81e101c00d1eabab">More...</a><br /></td></tr>
<tr class="separator:a21e826dfb081804c81e101c00d1eabab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e4809d411906cfd2a63c16112eed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchar.html">char</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#afe9e4809d411906cfd2a63c16112eed8">Get_Attribute_Key</a> () const</td></tr>
<tr class="memdesc:afe9e4809d411906cfd2a63c16112eed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in.  <a href="classAttribute__Request__Callback.html#afe9e4809d411906cfd2a63c16112eed8">More...</a><br /></td></tr>
<tr class="separator:afe9e4809d411906cfd2a63c16112eed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b10217f15d61f8ebb1aa766d96a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a7d5b10217f15d61f8ebb1aa766d96a95">Set_Attribute_Key</a> (<a class="el" href="classchar.html">char</a> const *attribute_key)</td></tr>
<tr class="memdesc:a7d5b10217f15d61f8ebb1aa766d96a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because the json key changes depending on if we request client-side or shared scope attributes and which type we requests depends on which method the class instance is passed as a parameter to.  <a href="classAttribute__Request__Callback.html#a7d5b10217f15d61f8ebb1aa766d96a95">More...</a><br /></td></tr>
<tr class="separator:a7d5b10217f15d61f8ebb1aa766d96a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66554b6988e6f9d684183556e39514bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classchar.html">char</a> const *, MaxAttributes &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a66554b6988e6f9d684183556e39514bd">Get_Attributes</a> () const</td></tr>
<tr class="memdesc:a66554b6988e6f9d684183556e39514bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client.  <a href="classAttribute__Request__Callback.html#a66554b6988e6f9d684183556e39514bd">More...</a><br /></td></tr>
<tr class="separator:a66554b6988e6f9d684183556e39514bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a9258846ef54b83e6dbb3096f6a9c7a3f">Set_Attributes</a> (Args const &amp;... args)</td></tr>
<tr class="memdesc:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. Directly forwards the given arguments to the overloaded vector assign method, meaning all combinatons of arguments that can call the assign method on a vector can be used to call this method. See possible overloaded vector assign methods <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a>, for the possible passed parameters. The possibilites mainly consist out of the fill assign method, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range assign method where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy assign method where we pass a vector and the values of that vector will be copied into our buffer.  <a href="classAttribute__Request__Callback.html#a9258846ef54b83e6dbb3096f6a9c7a3f">More...</a><br /></td></tr>
<tr class="separator:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c109ff7d7a863b078f0f08ab8786505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint64__t.html">uint64_t</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a8c109ff7d7a863b078f0f08ab8786505">Get_Timeout</a> () const</td></tr>
<tr class="memdesc:a8c109ff7d7a863b078f0f08ab8786505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of microseconds until we expect to have received a response.  <a href="classAttribute__Request__Callback.html#a8c109ff7d7a863b078f0f08ab8786505">More...</a><br /></td></tr>
<tr class="separator:a8c109ff7d7a863b078f0f08ab8786505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dae103dfc728278552b0ddc20f4e5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a0dae103dfc728278552b0ddc20f4e5d4">Set_Timeout</a> (<a class="el" href="classuint64__t.html">uint64_t</a> const &amp;timeout_microseconds)</td></tr>
<tr class="memdesc:a0dae103dfc728278552b0ddc20f4e5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of microseconds until we expect to have received a response.  <a href="classAttribute__Request__Callback.html#a0dae103dfc728278552b0ddc20f4e5d4">More...</a><br /></td></tr>
<tr class="separator:a0dae103dfc728278552b0ddc20f4e5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9399eb322efee12f81501d637eed4601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a9399eb322efee12f81501d637eed4601">Update_Timeout_Timer</a> ()</td></tr>
<tr class="memdesc:a9399eb322efee12f81501d637eed4601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the internal timeout timer.  <a href="classAttribute__Request__Callback.html#a9399eb322efee12f81501d637eed4601">More...</a><br /></td></tr>
<tr class="separator:a9399eb322efee12f81501d637eed4601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db2956478490d5e8b91df624069bcbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a3db2956478490d5e8b91df624069bcbd">Start_Timeout_Timer</a> ()</td></tr>
<tr class="memdesc:a3db2956478490d5e8b91df624069bcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the internal timeout timer if we actually received a configured valid timeout time and a valid callback. Is called as soon as the request is actually sent.  <a href="classAttribute__Request__Callback.html#a3db2956478490d5e8b91df624069bcbd">More...</a><br /></td></tr>
<tr class="separator:a3db2956478490d5e8b91df624069bcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289e746e318a35b70baa8416300dca5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a289e746e318a35b70baa8416300dca5c">Stop_Timeout_Timer</a> ()</td></tr>
<tr class="memdesc:a289e746e318a35b70baa8416300dca5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the internal timeout timer, is called as soon as an answer is received from the cloud if it isn't we call the previously subscribed callback instead.  <a href="classAttribute__Request__Callback.html#a289e746e318a35b70baa8416300dca5c">More...</a><br /></td></tr>
<tr class="separator:a289e746e318a35b70baa8416300dca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728c83641ec403ec1569a773e749cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a7728c83641ec403ec1569a773e749cbf">Set_Timeout_Callback</a> (<a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">Callback_Watchdog::function</a> timeout_callback)</td></tr>
<tr class="memdesc:a7728c83641ec403ec1569a773e749cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon request timeout (did not receive a response in the given timeout time)  <a href="classAttribute__Request__Callback.html#a7728c83641ec403ec1569a773e749cbf">More...</a><br /></td></tr>
<tr class="separator:a7728c83641ec403ec1569a773e749cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:a0077b0aca39845ce12519f53f20447a4 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a0077b0aca39845ce12519f53f20447a4">Callback</a> ()=default</td></tr>
<tr class="memdesc:a0077b0aca39845ce12519f53f20447a4 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#a0077b0aca39845ce12519f53f20447a4">More...</a><br /></td></tr>
<tr class="separator:a0077b0aca39845ce12519f53f20447a4 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dcfe6a129c933107a54328b208668e inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ab3dcfe6a129c933107a54328b208668e">Callback</a> (<a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">function</a> callback)</td></tr>
<tr class="memdesc:ab3dcfe6a129c933107a54328b208668e inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCallback.html#ab3dcfe6a129c933107a54328b208668e">More...</a><br /></td></tr>
<tr class="separator:ab3dcfe6a129c933107a54328b208668e inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8321239cd4ca3fe5eca2c21322f9e4 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a0f8321239cd4ca3fe5eca2c21322f9e4">Call_Callback</a> (argument_types const &amp;... arguments) const</td></tr>
<tr class="memdesc:a0f8321239cd4ca3fe5eca2c21322f9e4 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created. If the default constructor was used or a nullptr was passed instead of a valid function pointer, this method will check beforehand and simply return with a defaulted instance of the requested return variable.  <a href="classCallback.html#a0f8321239cd4ca3fe5eca2c21322f9e4">More...</a><br /></td></tr>
<tr class="separator:a0f8321239cd4ca3fe5eca2c21322f9e4 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c0a9633e5ba80b0a7269e6c4573ed2 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#ab4c0a9633e5ba80b0a7269e6c4573ed2">Set_Callback</a> (<a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">function</a> callback)</td></tr>
<tr class="memdesc:ab4c0a9633e5ba80b0a7269e6c4573ed2 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received serialized into the given argument types, used to change the callback initally passed or to set the callback if it was not passed as an argument initally.  <a href="classCallback.html#ab4c0a9633e5ba80b0a7269e6c4573ed2">More...</a><br /></td></tr>
<tr class="separator:ab4c0a9633e5ba80b0a7269e6c4573ed2 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:a23c47492ed6f514098c6fcfcf1354e02 inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">function</a> = std::function&lt; void(argument_types... arguments)&gt;</td></tr>
<tr class="memdesc:a23c47492ed6f514098c6fcfcf1354e02 inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">More...</a><br /></td></tr>
<tr class="separator:a23c47492ed6f514098c6fcfcf1354e02 inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t MaxAttributes = 1&gt;<br />
class Attribute_Request_Callback&lt; MaxAttributes &gt;</div><p >Client-side or shared attributes request callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Which attribute scope will be requested from either client-side or shared, is decided depending on which method the class instance is passed to as an argument. If that method is the Client_Attributes_Request() then the passed attributes are requested and if they exist are received from the client scope, but if that method is the Shared_Attributes_Request() then the passed attributes are requested and if they exist are received from the shared scope instead. To achieve that some internal member variables get set automatically by those methods, the first one being a string to differentiate which attribute scope was requested and the second being the id of the mqtt request, where the response by the server will use the same id, which makes it easy to know which method intially requested the data and should now receive it. Documentation about the specific use of Requesting client-side or shared scope atrributes in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MaxAttributes</td><td>Maximum amount of attributes that will ever be requested with this instance of the class, allows to use an array on the stack in the background. Be aware though the size set in this template and the size passed to the ThingsBoard MaxAttributes template need to be the same or the value in this class lower, if not some of the requested keys may be lost, default = Default_Attributes_Amount (5) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54f31ad9b6704885302369b8ae615f86" name="a54f31ad9b6704885302369b8ae615f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f31ad9b6704885302369b8ae615f86">&#9670;&#160;</a></span>Attribute_Request_Callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classAttribute__Request__Callback.html">::Attribute_Request_Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="ac98f2814c55d036de48c2e79e9fd0b1a" name="ac98f2814c55d036de48c2e79e9fd0b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98f2814c55d036de48c2e79e9fd0b1a">&#9670;&#160;</a></span>Attribute_Request_Callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classAttribute__Request__Callback.html">::Attribute_Request_Callback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">function</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint64__t.html">uint64_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em> = <code>0U</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">Callback_Watchdog::function</a>&#160;</td>
          <td class="paramname"><em>timeout_callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs callback, will be called upon client-side or shared attribute request arrival where the given multiple requested client-side or shared attributes were sent by the cloud and received by the client. Directly forwards the given arguments to the overloaded vector constructor, meaning all combinatons of arguments that would initalize a vector can be used to call this constructor. See possible vector constructors <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passed parameters. The possibilites mainly consist out of the fill constructor, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range constructor where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy constructor where we pass a vector and the values of that vector will be copied into our buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the vector constructor and therefore allow to use every overloaded vector constructor without having to implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> method that will be called upon data arrival with the given data that was received serialized into a JsonDocument </td></tr>
    <tr><td class="paramname">timeout_microseconds</td><td>Optional amount of microseconds until we expect to have received a response and if we didn't, we call the previously subscribed callback. If the value is 0 we will not start the timer and therefore never call the timeout callback method, default = 0 </td></tr>
    <tr><td class="paramname">timeout_callback</td><td>Optional callback method that will be called upon request timeout (did not receive a response in the given timeout time). Can happen if the requested method does not exist on the cloud, or if the connection could not be established, default = nullptr </td></tr>
    <tr><td class="paramname">...args</td><td>Arguments that will be forwarded into the overloaded vector constructor see <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe9e4809d411906cfd2a63c16112eed8" name="afe9e4809d411906cfd2a63c16112eed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9e4809d411906cfd2a63c16112eed8">&#9670;&#160;</a></span>Get_Attribute_Key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchar.html">char</a> const  * <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Attribute_Key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in. </p>
<dl class="section return"><dt>Returns</dt><dd>Key that the data is saved into, "client" for client-side attributes and "shared" for shared scope attributes </dd></dl>

</div>
</div>
<a id="a66554b6988e6f9d684183556e39514bd" name="a66554b6988e6f9d684183556e39514bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66554b6988e6f9d684183556e39514bd">&#9670;&#160;</a></span>Get_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classchar.html">char</a> const *, MaxAttributes &gt; &amp; <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. </p>
<dl class="section return"><dt>Returns</dt><dd>Requested client-side or shared attributes </dd></dl>

</div>
</div>
<a id="a5e5290f1d8b4228feab52a6f08ba862b" name="a5e5290f1d8b4228feab52a6f08ba862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5290f1d8b4228feab52a6f08ba862b">&#9670;&#160;</a></span>Get_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t const  &amp; <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Request_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>Unique identifier connected to the requested client-side or shared attributes </dd></dl>

</div>
</div>
<a id="a8c109ff7d7a863b078f0f08ab8786505" name="a8c109ff7d7a863b078f0f08ab8786505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c109ff7d7a863b078f0f08ab8786505">&#9670;&#160;</a></span>Get_Timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint64__t.html">uint64_t</a> const  &amp; <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the amount of microseconds until we expect to have received a response. </p>
<dl class="section return"><dt>Returns</dt><dd>Timeout time until timeout callback is called </dd></dl>

</div>
</div>
<a id="a7d5b10217f15d61f8ebb1aa766d96a95" name="a7d5b10217f15d61f8ebb1aa766d96a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5b10217f15d61f8ebb1aa766d96a95">&#9670;&#160;</a></span>Set_Attribute_Key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Attribute_Key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>attribute_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because the json key changes depending on if we request client-side or shared scope attributes and which type we requests depends on which method the class instance is passed as a parameter to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute_key</td><td>Key that the data is saved into, "client" for client-side attributes and "shared" for shared scope attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9258846ef54b83e6dbb3096f6a9c7a3f" name="a9258846ef54b83e6dbb3096f6a9c7a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258846ef54b83e6dbb3096f6a9c7a3f">&#9670;&#160;</a></span>Set_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Attributes </td>
          <td>(</td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. Directly forwards the given arguments to the overloaded vector assign method, meaning all combinatons of arguments that can call the assign method on a vector can be used to call this method. See possible overloaded vector assign methods <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a>, for the possible passed parameters. The possibilites mainly consist out of the fill assign method, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range assign method where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy assign method where we pass a vector and the values of that vector will be copied into our buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the vector assign method and therefore allow to use every overloaded vector assign without having to implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>Arguments that will be forwarded into the overloaded vector assign method see <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21e826dfb081804c81e101c00d1eabab" name="a21e826dfb081804c81e101c00d1eabab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e826dfb081804c81e101c00d1eabab">&#9670;&#160;</a></span>Set_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Request_ID </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>request_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because only the ThingsBoard class knows the current request id that this callback will be attached too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request_id</td><td>Unqiue identifier of the request for client-side or shared attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dae103dfc728278552b0ddc20f4e5d4" name="a0dae103dfc728278552b0ddc20f4e5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dae103dfc728278552b0ddc20f4e5d4">&#9670;&#160;</a></span>Set_Timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint64__t.html">uint64_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the amount of microseconds until we expect to have received a response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_microseconds</td><td>Timeout time until timeout callback is called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7728c83641ec403ec1569a773e749cbf" name="a7728c83641ec403ec1569a773e749cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728c83641ec403ec1569a773e749cbf">&#9670;&#160;</a></span>Set_Timeout_Callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Timeout_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#a23c47492ed6f514098c6fcfcf1354e02">Callback_Watchdog::function</a>&#160;</td>
          <td class="paramname"><em>timeout_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback method that will be called upon request timeout (did not receive a response in the given timeout time) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_callback</td><td><a class="el" href="classCallback.html" title="General purpose safe callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> function that will be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db2956478490d5e8b91df624069bcbd" name="a3db2956478490d5e8b91df624069bcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db2956478490d5e8b91df624069bcbd">&#9670;&#160;</a></span>Start_Timeout_Timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Start_Timeout_Timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the internal timeout timer if we actually received a configured valid timeout time and a valid callback. Is called as soon as the request is actually sent. </p>

</div>
</div>
<a id="a289e746e318a35b70baa8416300dca5c" name="a289e746e318a35b70baa8416300dca5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289e746e318a35b70baa8416300dca5c">&#9670;&#160;</a></span>Stop_Timeout_Timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Stop_Timeout_Timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the internal timeout timer, is called as soon as an answer is received from the cloud if it isn't we call the previously subscribed callback instead. </p>

</div>
</div>
<a id="a9399eb322efee12f81501d637eed4601" name="a9399eb322efee12f81501d637eed4601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9399eb322efee12f81501d637eed4601">&#9670;&#160;</a></span>Update_Timeout_Timer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Update_Timeout_Timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the internal timeout timer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Attribute__Request__Callback_8h_source.html">Attribute_Request_Callback.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
