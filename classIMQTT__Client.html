<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: IMQTT_Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.15.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classIMQTT__Client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IMQTT_Client Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement. Seperates the specific implementation used from the ThingsBoard client, allows to use different clients depending on different needs. In this case the main use case of the seperation is to both support Espressif IDF and Arduino with the following libraries as recommendations. The default MQTT Client for Arduino is the PubSubClient forked from ThingsBoard (<a href="https://github.com/thingsboard/pubsubclient">https://github.com/thingsboard/pubsubclient</a>), it includes fixes to solve issues with using std::function callbacks for non ESP boards. For Espressif IDF however the default MQTT Client is the esp-mqtt (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html</a>) component. The aforementioned recommendations are already implemented in the library and can can simply be used and included when using the library, for Arduino we can simply include Arduino_MQTT_Client and for Espressif IDF we can simply include the Espressif_MQTT_Client, the implementations have been tested and should be compatible when used in conjunction with the ThingsBoard client. However when using an implementation that does not allow for Arduino it is additional important to disable support for THINGSBOARD_ENABLE_STREAM_UTILS, because this feature relies on Arduino as it improves the underlying data streams to directly write the data into the MQTT Client, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint.  
 <a href="classIMQTT__Client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4494b3cee25b1fed5ed6049aa9016bec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec">set_data_callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classchar.html">char</a> *, <a class="el" href="classuint8__t.html">uint8_t</a> *, unsigned int &gt;::function callback)=0</td></tr>
<tr class="memdesc:a4494b3cee25b1fed5ed6049aa9016bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if any message is received by the MQTT broker, including the topic string that the message was received over, as well as the payload data and the size of that payload data. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing.  <a href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec">More...</a><br /></td></tr>
<tr class="separator:a4494b3cee25b1fed5ed6049aa9016bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#ad07f448cb4962ff6ddfed17aa743ffb9">set_connect_callback</a> (<a class="el" href="classCallback.html">Callback</a>&lt; void &gt;::function callback)=0</td></tr>
<tr class="memdesc:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if we have successfully established a connection with the MQTT broker. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing.  <a href="classIMQTT__Client.html#ad07f448cb4962ff6ddfed17aa743ffb9">More...</a><br /></td></tr>
<tr class="separator:ad07f448cb4962ff6ddfed17aa743ffb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f54876f0f75c30bcb589621318b0add"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a6f54876f0f75c30bcb589621318b0add">set_buffer_size</a> (uint16_t receive_buffer_size, uint16_t send_buffer_size)=0</td></tr>
<tr class="memdesc:a6f54876f0f75c30bcb589621318b0add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the buffer for sent and received MQTT messages, using a bigger value than uint16_t for passing the buffer size does not make any sense because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter.  <a href="classIMQTT__Client.html#a6f54876f0f75c30bcb589621318b0add">More...</a><br /></td></tr>
<tr class="separator:a6f54876f0f75c30bcb589621318b0add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9273edc7b3559e3fcde199ee13add1"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a3f9273edc7b3559e3fcde199ee13add1">get_receive_buffer_size</a> ()=0</td></tr>
<tr class="memdesc:a3f9273edc7b3559e3fcde199ee13add1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size for sent MQTT data.  <a href="classIMQTT__Client.html#a3f9273edc7b3559e3fcde199ee13add1">More...</a><br /></td></tr>
<tr class="separator:a3f9273edc7b3559e3fcde199ee13add1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9a7ac6bd2e2d61f9efda039a1e9a4838">get_send_buffer_size</a> ()=0</td></tr>
<tr class="memdesc:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size for received MQTT data.  <a href="classIMQTT__Client.html#a9a7ac6bd2e2d61f9efda039a1e9a4838">More...</a><br /></td></tr>
<tr class="separator:a9a7ac6bd2e2d61f9efda039a1e9a4838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9098518b44d6991842b8b73f05e37913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9098518b44d6991842b8b73f05e37913">set_server</a> (<a class="el" href="classchar.html">char</a> const *domain, uint16_t port)=0</td></tr>
<tr class="memdesc:a9098518b44d6991842b8b73f05e37913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the server and port that the client should connect to MQTT over, should be called atleast once before calling <a class="el" href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395" title="Connects to the previously with set_server configured server instance that should be connected to ove...">connect()</a> so it is clear which server to connect too.  <a href="classIMQTT__Client.html#a9098518b44d6991842b8b73f05e37913">More...</a><br /></td></tr>
<tr class="separator:a9098518b44d6991842b8b73f05e37913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de7ff0f7d65326e6b638591c36e7395"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395">connect</a> (<a class="el" href="classchar.html">char</a> const *client_id, <a class="el" href="classchar.html">char</a> const *user_name, <a class="el" href="classchar.html">char</a> const *password)=0</td></tr>
<tr class="memdesc:a1de7ff0f7d65326e6b638591c36e7395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the previously with set_server configured server instance that should be connected to over the previously defined port.  <a href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395">More...</a><br /></td></tr>
<tr class="separator:a1de7ff0f7d65326e6b638591c36e7395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb78386592aa959e1ba68131c7cf93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">disconnect</a> ()=0</td></tr>
<tr class="memdesc:a05cb78386592aa959e1ba68131c7cf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects from a previously connected server and should release all used resources.  <a href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">More...</a><br /></td></tr>
<tr class="separator:a05cb78386592aa959e1ba68131c7cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bf1e088f569976adfd524e029f9d23"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">loop</a> ()=0</td></tr>
<tr class="memdesc:a14bf1e088f569976adfd524e029f9d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives and sends any outstanding messages from and to the MQTT broker.  <a href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">More...</a><br /></td></tr>
<tr class="separator:a14bf1e088f569976adfd524e029f9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98289274313ffb902bcce37c11c500b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a98289274313ffb902bcce37c11c500b8">publish</a> (<a class="el" href="classchar.html">char</a> const *topic, <a class="el" href="classuint8__t.html">uint8_t</a> const *payload, size_t const &amp;length)=0</td></tr>
<tr class="memdesc:a98289274313ffb902bcce37c11c500b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given payload over the previously established connection with connect.  <a href="classIMQTT__Client.html#a98289274313ffb902bcce37c11c500b8">More...</a><br /></td></tr>
<tr class="separator:a98289274313ffb902bcce37c11c500b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4833fb14319650281e060c239a7f19"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#acf4833fb14319650281e060c239a7f19">subscribe</a> (<a class="el" href="classchar.html">char</a> const *topic)=0</td></tr>
<tr class="memdesc:acf4833fb14319650281e060c239a7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec" title="Sets the callback that is called, if any message is received by the MQTT broker, including the topic ...">set_data_callback()</a> with the received data.  <a href="classIMQTT__Client.html#acf4833fb14319650281e060c239a7f19">More...</a><br /></td></tr>
<tr class="separator:acf4833fb14319650281e060c239a7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53e8dcc18899b63532f47da2bbace3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a5a53e8dcc18899b63532f47da2bbace3">unsubscribe</a> (<a class="el" href="classchar.html">char</a> const *topic)=0</td></tr>
<tr class="memdesc:a5a53e8dcc18899b63532f47da2bbace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes to previously subscribed MQTT message on the given topic.  <a href="classIMQTT__Client.html#a5a53e8dcc18899b63532f47da2bbace3">More...</a><br /></td></tr>
<tr class="separator:a5a53e8dcc18899b63532f47da2bbace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe357c2b35a844c9643d328af29ada"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">connected</a> ()=0</td></tr>
<tr class="memdesc:a9dfe357c2b35a844c9643d328af29ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet.  <a href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">More...</a><br /></td></tr>
<tr class="separator:a9dfe357c2b35a844c9643d328af29ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement. Seperates the specific implementation used from the ThingsBoard client, allows to use different clients depending on different needs. In this case the main use case of the seperation is to both support Espressif IDF and Arduino with the following libraries as recommendations. The default MQTT Client for Arduino is the PubSubClient forked from ThingsBoard (<a href="https://github.com/thingsboard/pubsubclient">https://github.com/thingsboard/pubsubclient</a>), it includes fixes to solve issues with using std::function callbacks for non ESP boards. For Espressif IDF however the default MQTT Client is the esp-mqtt (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html</a>) component. The aforementioned recommendations are already implemented in the library and can can simply be used and included when using the library, for Arduino we can simply include Arduino_MQTT_Client and for Espressif IDF we can simply include the Espressif_MQTT_Client, the implementations have been tested and should be compatible when used in conjunction with the ThingsBoard client. However when using an implementation that does not allow for Arduino it is additional important to disable support for THINGSBOARD_ENABLE_STREAM_UTILS, because this feature relies on Arduino as it improves the underlying data streams to directly write the data into the MQTT Client, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1de7ff0f7d65326e6b638591c36e7395" name="a1de7ff0f7d65326e6b638591c36e7395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de7ff0f7d65326e6b638591c36e7395">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects to the previously with set_server configured server instance that should be connected to over the previously defined port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client identification code, that allows to differentiate which MQTT device is sending the traffic to the MQTT broker </td></tr>
    <tr><td class="paramname">user_name</td><td>Client username that is used to authenticate, who is connecting over MQTT </td></tr>
    <tr><td class="paramname">password</td><td>Client password that is used to authenticate, who is connecting over MQTT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the client could establish the connection successfully or not </dd></dl>

</div>
</div>
<a id="a9dfe357c2b35a844c9643d328af29ada" name="a9dfe357c2b35a844c9643d328af29ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfe357c2b35a844c9643d328af29ada">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the client is currently connected or not </dd></dl>

</div>
</div>
<a id="a05cb78386592aa959e1ba68131c7cf93" name="a05cb78386592aa959e1ba68131c7cf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb78386592aa959e1ba68131c7cf93">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnects from a previously connected server and should release all used resources. </p>

</div>
</div>
<a id="a3f9273edc7b3559e3fcde199ee13add1" name="a3f9273edc7b3559e3fcde199ee13add1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9273edc7b3559e3fcde199ee13add1">&#9670;&#160;</a></span>get_receive_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t IMQTT_Client::get_receive_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size for sent MQTT data. </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer </dd></dl>

</div>
</div>
<a id="a9a7ac6bd2e2d61f9efda039a1e9a4838" name="a9a7ac6bd2e2d61f9efda039a1e9a4838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7ac6bd2e2d61f9efda039a1e9a4838">&#9670;&#160;</a></span>get_send_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t IMQTT_Client::get_send_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size for received MQTT data. </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer </dd></dl>

</div>
</div>
<a id="a14bf1e088f569976adfd524e029f9d23" name="a14bf1e088f569976adfd524e029f9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf1e088f569976adfd524e029f9d23">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives and sends any outstanding messages from and to the MQTT broker. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether sending or receiving the oustanding the messages was successful or not, should return false if an internal error occured or the connection has been lost </dd></dl>

</div>
</div>
<a id="a98289274313ffb902bcce37c11c500b8" name="a98289274313ffb902bcce37c11c500b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98289274313ffb902bcce37c11c500b8">&#9670;&#160;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint8__t.html">uint8_t</a> const *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the given payload over the previously established connection with connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic that the message is sent over, where different MQTT topics expect a different kind of payload </td></tr>
    <tr><td class="paramname">payload</td><td>Payload containg the json data that should be sent </td></tr>
    <tr><td class="paramname">length</td><td>Length of the payload in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether publishing the payload on the given topic was successful or not </dd></dl>

</div>
</div>
<a id="a6f54876f0f75c30bcb589621318b0add" name="a6f54876f0f75c30bcb589621318b0add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54876f0f75c30bcb589621318b0add">&#9670;&#160;</a></span>set_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>receive_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the buffer for sent and received MQTT messages, using a bigger value than uint16_t for passing the buffer size does not make any sense because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receive_buffer_size</td><td>Maximum amount of data that can be received via MQTT at once, expected behaviour is that, if bigger packets are received they are discarded and a warning is printed to the console. Should be big enough to hold the biggest response that is expected to be ever received by the device at once. </td></tr>
    <tr><td class="paramname">send_buffer_size</td><td>Maximum amount of data that can be sent via MQTT at once, expected behaviour is that, if we attempt to send data that is bigger, it will simply not be sent and a message is printed to the console instead. Should be big enough to hold the biggest request that is expected to be ever sent by the device at once. Alternatively it is possible if THINGSBOARD_ENABLE_STREAM_UTILS is enabled, requires using the Arduino framework and simply installing StreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library, to only set the value of this paramter to the same value as the buffering_size passed to the constructor + enough memory to hold the topic and MQTT Header ~= 20 bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether allocating the needed memory for the given buffer sizes was successful or not </dd></dl>

</div>
</div>
<a id="ad07f448cb4962ff6ddfed17aa743ffb9" name="ad07f448cb4962ff6ddfed17aa743ffb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07f448cb4962ff6ddfed17aa743ffb9">&#9670;&#160;</a></span>set_connect_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_connect_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if we have successfully established a connection with the MQTT broker. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on established MQTT connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4494b3cee25b1fed5ed6049aa9016bec" name="a4494b3cee25b1fed5ed6049aa9016bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4494b3cee25b1fed5ed6049aa9016bec">&#9670;&#160;</a></span>set_data_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_data_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html">Callback</a>&lt; void, <a class="el" href="classchar.html">char</a> *, <a class="el" href="classuint8__t.html">uint8_t</a> *, unsigned int &gt;::function&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if any message is received by the MQTT broker, including the topic string that the message was received over, as well as the payload data and the size of that payload data. Directly set by the used ThingsBoard client to its internal methods, therefore calling again and overriding as a user ist not recommended, unless you know what you are doing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on received MQTT response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9098518b44d6991842b8b73f05e37913" name="a9098518b44d6991842b8b73f05e37913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9098518b44d6991842b8b73f05e37913">&#9670;&#160;</a></span>set_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the server and port that the client should connect to MQTT over, should be called atleast once before calling <a class="el" href="classIMQTT__Client.html#a1de7ff0f7d65326e6b638591c36e7395" title="Connects to the previously with set_server configured server instance that should be connected to ove...">connect()</a> so it is clear which server to connect too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Server instance name the client should connect too </td></tr>
    <tr><td class="paramname">port</td><td>Port that will be used to establish a connection and send / receive data Should be either 1883 for unencrypted MQTT or 8883 for MQTT with TLS/SSL encryption. The latter is recommended if relevant data is sent or if the client receives and handles Remote Procedure Calls or Shared Attribute Update Callbacks from the server, because using an unencrpyted connection, will allow 3rd parties to listen to the communication and impersonate the server sending payloads which might influence the device in unexpected ways. However if Over the Air udpates are enabled secure communication should definetly be enabled, because if that is not done a 3rd party might impersonate the server sending a malicious payload, which is then flashed onto the device instead of the real firmware. Which depeding on the payload might even be able to destroy the device or make it otherwise unusable. See <a href="https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/">https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/</a> for more information on the aforementioned security risk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4833fb14319650281e060c239a7f19" name="acf4833fb14319650281e060c239a7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4833fb14319650281e060c239a7f19">&#9670;&#160;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4494b3cee25b1fed5ed6049aa9016bec" title="Sets the callback that is called, if any message is received by the MQTT broker, including the topic ...">set_data_callback()</a> with the received data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic we want to receive a notification about if messages are sent by the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter subscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic does not exist </dd></dl>

</div>
</div>
<a id="a5a53e8dcc18899b63532f47da2bbace3" name="a5a53e8dcc18899b63532f47da2bbace3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a53e8dcc18899b63532f47da2bbace3">&#9670;&#160;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a> const *&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribes to previously subscribed MQTT message on the given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic we want to stop receiving a notification about if messages are sent by the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter unsubscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic was not previously subscribed </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
