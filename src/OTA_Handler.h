/*
  OTA_Handler.h - Library API for sending data to the ThingsBoard
  Based on PubSub MQTT library.
  Created by Olender M. Oct 2018.
  Released into the public domain.
*/
#ifndef OTA_Handler_h
#define OTA_Handler_h

// Local include.
#include "Configuration.h"

#if THINGSBOARD_ENABLE_OTA

// Local include.
#include "Callback_Watchdog.h"
#include "HashGenerator.h"
#include "Helper.h"
#include "OTA_Update_Callback.h"
#include "OTA_Failure_Response.h"

// Library include.
#ifdef ESP8266
#include <Updater.h>
#else
#ifdef ESP32
#include <Update.h>
#endif // ESP32
#endif // ESP8266

/// ---------------------------------
/// Constant strings in flash memory.
/// ---------------------------------
// Firmware data keys.
#if THINGSBOARD_ENABLE_PROGMEM
constexpr char FW_STATE_DOWNLOADING[] PROGMEM = "DOWNLOADING";
constexpr char FW_STATE_DOWNLOADED[] PROGMEM = "DOWNLOADED";
constexpr char FW_STATE_VERIFIED[] PROGMEM = "VERIFIED";
constexpr char FW_STATE_UPDATING[] PROGMEM = "UPDATING";
constexpr char FW_STATE_FAILED[] PROGMEM = "FAILED";
#else
constexpr char FW_STATE_DOWNLOADING[] = "DOWNLOADING";
constexpr char FW_STATE_DOWNLOADED[] = "DOWNLOADED";
constexpr char FW_STATE_VERIFIED[] = "VERIFIED";
constexpr char FW_STATE_UPDATING[] = "UPDATING";
constexpr char FW_STATE_FAILED[] = "FAILED";
#endif // THINGSBOARD_ENABLE_PROGMEM

// Log messages.
#if THINGSBOARD_ENABLE_PROGMEM
constexpr char UNABLE_TO_REQUEST_CHUNCKS[] PROGMEM = "Unable to request firmware chunk";
constexpr char ERROR_UPDATE_BEGIN[] PROGMEM = "Error during Update.begin";
constexpr char ERROR_UPDATE_WRITE[] PROGMEM = "Error during Update.write";
constexpr char UPDATING_HASH_FAILED[] PROGMEM = "Updating hash failed";
constexpr char ERROR_UPDATE_END[] PROGMEM = "Error during Update.end, not all bytes written";
constexpr char CHKS_VER_FAILED[] PROGMEM = "Checksum verification failed";
constexpr char SLASH PROGMEM = '/';
constexpr char FW_CHUNK[] PROGMEM = "Receive chunk (%i), with size (%u) bytes";
constexpr char HASH_ACTUAL[] PROGMEM = "(%s) actual checksum: (%s)";
constexpr char HASH_EXPECTED[] PROGMEM = "(%s) expected checksum: (%s)";
constexpr char CHKS_VER_SUCCESS[] PROGMEM = "Checksum is the same as expected";
constexpr char FW_UPDATE_SUCCESS[] PROGMEM = "Update success";
#else
constexpr char UNABLE_TO_REQUEST_CHUNCKS[] = "Unable to request firmware chunk";
constexpr char ERROR_UPDATE_BEGIN[] = "Error during Update.begin";
constexpr char ERROR_UPDATE_WRITE[] = "Error during Update.write";
constexpr char UPDATING_HASH_FAILED[] = "Updating hash failed";
constexpr char ERROR_UPDATE_END[] = "Error during Update.end, not all bytes written";
constexpr char CHKS_VER_FAILED[] = "Checksum verification failed";
constexpr char SLASH = '/';
constexpr char FW_CHUNK[] = "Receive chunk (%i), with size (%u) bytes";
constexpr char HASH_ACTUAL[] = "(%s) actual checksum: (%s)";
constexpr char HASH_EXPECTED[] = "(%s) expected checksum: (%s)";
constexpr char CHKS_VER_SUCCESS[] = "Checksum is the same as expected";
constexpr char FW_UPDATE_SUCCESS[] = "Update success";
#endif // THINGSBOARD_ENABLE_PROGMEM

/// @brief Handles sending and handling received OTA package requests from the MQTT broker
/// @tparam Logger Logging class that should be used to print messages generated by ThingsBoard
template<typename Logger>
class OTA_Handler {
  public:
    /// @brief Constructor
    OTA_Handler(const OTA_Update_Callback *fw_callback, OnReceiveCb reconnect_callback, std::function<bool(const uint32_t&)> publish_callback, std::function<bool(const char *, const char *)> send_fw_state_callback, std::function<bool()> finish_callback, const uint32_t& fw_size, const std::string& fw_algorithm, const std::string& fw_checksum, const mbedtls_md_type_t& fw_checksum_algorithm)
        : m_fw_callback(fw_callback)
        , m_reconnect_callback(reconnect_callback)
        , m_publish_callback(publish_callback)
        , m_send_fw_state_callback(send_fw_state_callback)
        , m_finish_callback(finish_callback)
        , m_fw_size(fw_size)
        , m_fw_algorithm(fw_algorithm)
        , m_fw_checksum(fw_checksum)
        , m_fw_checksum_algorithm(fw_checksum_algorithm)
        , m_hash()
        , m_total_chunks(0U)
        , m_downloaded_chunks(0U)
        , m_retries(0U)
        , m_watchdog()
    {
      // Nothing to do.
    }

    inline void Start_Firmware_Update() {
        if (!m_reconnect_callback || !m_publish_callback || !m_send_fw_state_callback || !m_finish_callback) {
          Logger::log(OTA_CB_IS_NULL);
          (void)m_send_fw_state_callback(FW_STATE_FAILED, OTA_CB_IS_NULL);
            return Handle_Failure(OTA_Failure_Response::RETRY_NOTHING);
        }

        if (!m_publish_callback(0U)) {
          Logger::log(UNABLE_TO_REQUEST_CHUNCKS);
          (void)m_send_fw_state_callback(FW_STATE_FAILED, UNABLE_TO_REQUEST_CHUNCKS);
            return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
        }

        m_total_chunks = (m_fw_size / m_fw_callback->Get_Chunk_Size()) + 1U;
        m_retries = m_fw_callback->Get_Chunk_Retries();
        m_hash.start(m_fw_checksum_algorithm);
        m_watchdog.start(m_fw_callback->Get_Timeout() * 1000, std::bind(&OTA_Handler::Handle_Request_Timeout, this));
        // Ensure to call Update.abort after calling Update.begin even if it failed,
        // to make sure that any possibly started processes are stopped and freed.
#ifdef ESP32
        Update.abort();
#endif
    }

    inline void Process_Firmware_Packet(char *topic, uint8_t *payload, const uint32_t& length) {
        m_watchdog.feed();

        (void)m_send_fw_state_callback(FW_STATE_DOWNLOADING, nullptr);

        const uint32_t current_chunk = atoi(strrchr(topic, SLASH) + 1U);

        char message[Helper::detectSize(FW_CHUNK, current_chunk, length)];
        snprintf_P(message, sizeof(message), FW_CHUNK, current_chunk, length);
        Logger::log(message);

        if (current_chunk == 0) {
            // Initialize Flash
            if (!Update.begin(m_fw_size)) {
              Logger::log(ERROR_UPDATE_BEGIN);
              (void)m_send_fw_state_callback(FW_STATE_FAILED, ERROR_UPDATE_BEGIN);
              return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
            }
        }

        // Write received binary data to flash partition
        if (Update.write(payload, length) != length) {
            Logger::log(ERROR_UPDATE_WRITE);
            (void)m_send_fw_state_callback(FW_STATE_FAILED, ERROR_UPDATE_WRITE);
            return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
        }

        // Update value only if writing to flash was a success
        if (!m_hash.update(payload, length)) {
            Logger::log(UPDATING_HASH_FAILED);
            (void)m_send_fw_state_callback(FW_STATE_FAILED, UPDATING_HASH_FAILED);
            return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
        }

        m_downloaded_chunks = current_chunk;
        m_fw_callback->Call_Progress_Callback<Logger>(m_downloaded_chunks, m_total_chunks);

        // Reset retries as the current chunk has been downloaded and handled successfully
        m_retries = m_fw_callback->Get_Chunk_Retries();
    }

    inline void Request_Next_Firmware_Packet() {
        // Check if we wrote and hashed the last firmware chunk already
        if (m_downloaded_chunks >= m_total_chunks) {
            Finish_Firmware_Update();   
            return;
        }

        if (m_publish_callback(m_downloaded_chunks + 1)) {
          return;
        }

        Logger::log(UNABLE_TO_REQUEST_CHUNCKS);
        (void)m_send_fw_state_callback(FW_STATE_FAILED, UNABLE_TO_REQUEST_CHUNCKS);
        return Handle_Failure(OTA_Failure_Response::RETRY_CHUNK);
    }

  private:
    const OTA_Update_Callback *m_fw_callback;
    OnReceiveCb m_reconnect_callback;
    std::function<bool(const uint32_t&)> m_publish_callback;
    std::function<bool(const char *, const char *)> m_send_fw_state_callback;
    std::function<bool()> m_finish_callback;
    // Allows for a binary size of up to theoretically 4 GB.
    const uint32_t m_fw_size;
    const std::string m_fw_algorithm;
    const std::string m_fw_checksum;
    const mbedtls_md_type_t m_fw_checksum_algorithm;
    HashGenerator m_hash;
    uint32_t m_total_chunks;
    uint32_t m_downloaded_chunks;
    uint8_t m_retries;
    Callback_Watchdog m_watchdog;

    inline void Finish_Firmware_Update() {
        (void)m_send_fw_state_callback(FW_STATE_DOWNLOADED, nullptr);

        const std::string calculated_hash = m_hash.get_hash_string();
        char actual[JSON_STRING_SIZE(strlen(HASH_ACTUAL)) + JSON_STRING_SIZE(m_fw_algorithm.size()) + JSON_STRING_SIZE(calculated_hash.size())];
        snprintf_P(actual, sizeof(actual), HASH_ACTUAL, m_fw_algorithm.c_str(), calculated_hash.c_str());
        Logger::log(actual);

        char expected[JSON_STRING_SIZE(strlen(HASH_EXPECTED)) + JSON_STRING_SIZE(m_fw_algorithm.size()) + JSON_STRING_SIZE(m_fw_checksum.size())];
        snprintf_P(expected, sizeof(expected), HASH_EXPECTED, m_fw_algorithm.c_str(), m_fw_checksum.c_str());
        Logger::log(expected);

        // Check if the initally received checksum is the same as the one we calculated from the received binary data,
        // if not we assume the binary data has been changed or not completly downloaded --> Firmware update failed
        if (m_fw_checksum.compare(calculated_hash) != 0) {
            Logger::log(CHKS_VER_FAILED);
            (void)m_send_fw_state_callback(FW_STATE_FAILED, CHKS_VER_FAILED);
            return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
        }

        Logger::log(CHKS_VER_SUCCESS);

        if (!Update.end()) {
            Logger::log(ERROR_UPDATE_END);
            (void)m_send_fw_state_callback(FW_STATE_FAILED, ERROR_UPDATE_END);
            return Handle_Failure(OTA_Failure_Response::RETRY_UPDATE);
        }

        Logger::log(FW_UPDATE_SUCCESS);
        (void)m_send_fw_state_callback(FW_STATE_UPDATING, nullptr);

        m_fw_callback->Call_End_Callback<Logger>(true);
        (void)m_finish_callback();
    }

    inline void Handle_Failure(const OTA_Failure_Response& failure_response) {
      // Decrease the amount of retries of downloads for the current chunk,
      // reset as soon as the next chunk has been received and handled successfully
      m_retries--;

      switch (failure_response) {
        case OTA_Failure_Response::RETRY_CHUNK:
          Request_Next_Firmware_Packet();
          break;
        case OTA_Failure_Response::RETRY_UPDATE:
          Start_Firmware_Update();
          break;
        case OTA_Failure_Response::RETRY_NOTHING:
          m_retries = 0;
          break;
        default:
          // Nothing to do.
          break;
      }

      if (m_retries <= 0) {
          m_fw_callback->Call_End_Callback<Logger>(false);
          (void)m_finish_callback();
          return;
      }
    }

    inline void Handle_Request_Timeout() {
      m_reconnect_callback();
      Handle_Failure(OTA_Failure_Response::RETRY_CHUNK);
    }
};

#endif // THINGSBOARD_ENABLE_OTA

#endif // OTA_Handler_h
