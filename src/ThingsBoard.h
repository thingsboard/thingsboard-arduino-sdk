#ifndef ThingsBoard_h
#define ThingsBoard_h

// Local includes.
#include "Constants.h"
#include "API_Implementation.h"
#include "IMQTT_Client.h"
#include "DefaultLogger.h"
#include "Telemetry.h"

// Library includes.
#if THINGSBOARD_ENABLE_STREAM_UTILS
#include <StreamUtils.h>
#endif // THINGSBOARD_ENABLE_STREAM_UTILS


uint16_t constexpr DEFAULT_MQTT_PORT = 1883U;
char constexpr PROV_ACCESS_TOKEN[] = "provision";
// Publish data topics.
char constexpr TELEMETRY_TOPIC[] = "v1/devices/me/telemetry";
// Log messages.
char constexpr UNABLE_TO_DE_SERIALIZE_JSON[] = "Unable to de-serialize received json data with error (DeserializationError::%s)";
char constexpr INVALID_BUFFER_SIZE[] = "Buffer size (%u) to small for the given payloads size (%u), increase with setBufferSize accordingly or set THINGSBOARD_ENABLE_STREAM_UTILS to 1 before including ThingsBoard";
char constexpr UNABLE_TO_ALLOCATE_BUFFER[] = "Allocating memory for the internal MQTT buffer failed";
#if THINGSBOARD_ENABLE_DEBUG
char constexpr RECEIVE_MESSAGE[] = "Received data from server over topic (%s)";
char constexpr SEND_MESSAGE[] = "Sending data to server over topic (%s) with data (%s)";
char constexpr SEND_SERIALIZED[] = "Hidden, because json data is bigger than buffer, therefore showing in console is skipped";
#endif // THINGSBOARD_ENABLE_DEBUG
// Claim topics.
char constexpr CLAIM_TOPIC[] = "v1/devices/me/claim";
// Claim data keys.
char constexpr SECRET_KEY[] = "secretKey";
char constexpr DURATION_KEY[] = "durationMs";


#if THINGSBOARD_ENABLE_DYNAMIC
/// @brief Wrapper around any arbitrary MQTT Client implementing the IMQTT_Client interface, to allow connecting and sending / retrieving data from ThingsBoard over the MQTT or MQTT with TLS/SSL protocol.
/// BufferSize of the underlying data buffer can be changed during the runtime and the maximum amount of data points that can ever be sent or received are automatically deduced at runtime.
/// Additionally, there are internal vectors that hold all subscriptions and requests and dynamically allocate memory on the heap, depending on how much space we currently require.
/// Furthermore, there are internal vectors in the Shared_Attribute_Callback and the Attribute_Request_Callback, which hold the amount of keys we want to request or subscribe to updates too.
/// Dynamically increasing the internal size, allows to adjust how much space we require depending on the amount of subscribed or requested keys.
/// If this feature of automatic deduction, is not needed, or not wanted because it allocates memory on the heap, then the values can be set once as template arguements.
/// Simply set THINGSBOARD_ENABLE_DYNAMIC to 0, before including ThingsBoard.h
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = DefaultLogger
template <typename Logger = DefaultLogger>
#else
/// @brief Wrapper around any arbitrary MQTT Client implementing the IMQTT_Client interface, to allow connecting and sending / retrieving data from ThingsBoard over the MQTT or MQTT with TLS/SSL protocol.
/// BufferSize of the underlying data buffer can be changed during the runtime and the maximum amount of data points that can ever be can be set once as template argument.
/// Additionally, there are internal arrays that hold all subscriptions and requests and statically allocate memory on the stack, which can also be set once as a template argument.
/// Furthermore, there are the maximum amount of values for the internal arrays of the Shared_Attribute_Callback and the Attribute_Request_Callback, which hold the amount of keys we want to request or subscribe to updates too
/// Setting a fixed size, allows to allocate the variables in the container on the stack, which can also be set once as a template argument.
/// Changing is only possible if a new instance of this class is created. If these values should be automatically deduced at runtime instead then, and then dynamically allocated on the heap,
/// simply set THINGSBOARD_ENABLE_DYNAMIC to 1, before including ThingsBoard.h
/// @tparam MaxFieldsAmount Maximum amount of key value pair that we will be able to sent or received by ThingsBoard in one call, default = Default_Fields_Amount (8)
/// @tparam MaxEndpointsAmount Maximum amount of subscribed API endpoints, Default_Endpoints_Amount is used as the default value because it is big enough to hold one instance of every possible API Implementation, default = Default_Endpoints_Amount (7)
/// @tparam Logger Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set, default = DefaultLogger
template<size_t MaxFieldsAmount = Default_Fields_Amount, size_t MaxEndpointsAmount = Default_Endpoints_Amount, typename Logger = DefaultLogger>
#endif // THINGSBOARD_ENABLE_DYNAMIC
class ThingsBoardSized {
  public:
    /// @brief Constructs a ThingsBoardSized instance with the given network client that should be used to establish the connection to ThingsBoard
    /// @tparam InputIterator Class that points to the begin and end iterator
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @param client MQTT Client implementation that should be used to establish the connection to ThingsBoard
    /// @param first Iterator pointing to the first API implementation that we want to be handled by this class.
    /// The API implementation by itself does nothing, it needs to be connected to actively send and receive information.
    /// Additionally to save memory we only save non-owning pointers to the actual implementations, therefore the implementations from the user must be kept alive, for as long as the connected instance
    /// @param last Iterator pointing to one past the end of the elements we want to copy into our underlying data container
    /// @param bufferSize Maximum amount of data that can be either received or sent to ThingsBoard at once, if bigger packets are received they are discarded
    /// and if we attempt to send data that is bigger, it will not be sent, the internal value can be changed later at any time with the setBufferSize() method
    /// alternatively setting THINGSBOARD_ENABLE_STREAM_UTILS to 1 allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation
    /// can be theoretically set to only be as big as the biggest message we should every receive from ThingsBoard,
    /// this will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal buffer,
    /// which needs more time than sending a message directly but has the advantage of requiring less memory.
    /// So if that is a problem on the board it might be useful to enable the THINGSBOARD_ENABLE_STREAM_UTILS option
    /// and decrease the internal buffer size of the mqtt client to what is needed to receive all MQTT messages,
    /// that size can vary but if all ThingsBoard features are used a buffer size of 256 bytes should suffice for receiving most responses.
    /// If the aforementioned feature is not enabled the buffer size might need to be much bigger though,
    /// but in that case if a message was too big to be sent the user will be informed with a message to the Logger.
    /// The aforementioned options can only be enabled if Arduino is used to build this library, because the StreamUtils library requires it, default = Default_Payload (64)
    /// @param maxStackSize Maximum amount of bytes we want to allocate on the stack, default = Default_Max_Stack_Size (1024)
    template<typename InputIterator>
#if !THINGSBOARD_ENABLE_STREAM_UTILS
    ThingsBoardSized(IMQTT_Client& client, InputIterator const & first, InputIterator const & last, uint16_t bufferSize = Default_Payload, size_t const & maxStackSize = Default_Max_Stack_Size)
#else
    /// @param bufferingSize Amount of bytes allocated to speed up serialization, default = Default_Buffering_Size (64)
    ThingsBoardSized(IMQTT_Client& client, InputIterator const & first, InputIterator const & last, uint16_t bufferSize = Default_Payload, size_t const & maxStackSize = Default_Max_Stack_Size, size_t const & bufferingSize = Default_Buffering_Size)
#endif // THINGSBOARD_ENABLE_STREAM_UTILS
      : m_client(client)
      , m_max_stack(maxStackSize)
#if THINGSBOARD_ENABLE_STREAM_UTILS
      , m_buffering_size(bufferingSize)
#endif // THINGSBOARD_ENABLE_STREAM_UTILS
      , m_api_implementations(first, last)
    {
        for (auto & api : m_api_implementations) {
            if (api == nullptr) {
                continue;
            }
#if THINGSBOARD_ENABLE_STL
            api->Set_Client_Callbacks(std::bind(&ThingsBoardSized::Subscribe_API_Implementation, this, std::placeholders::_1), std::bind(&ThingsBoardSized::sendTelemetryJson, this, std::placeholders::_1, std::placeholders::_2), std::bind(&ThingsBoardSized::Send_Json, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3), std::bind(&ThingsBoardSized::Send_Json_String, this, std::placeholders::_1, std::placeholders::_2), std::bind(&ThingsBoardSized::clientSubscribe, this, std::placeholders::_1), std::bind(&ThingsBoardSized::clientUnsubscribe, this, std::placeholders::_1), std::bind(&ThingsBoardSized::getClientBufferSize, this), std::bind(&ThingsBoardSized::setBufferSize, this, std::placeholders::_1));
#else
            api->Set_Client_Callbacks(ThingsBoardSized::staticSubscribeImplementation, ThingsBoardSized::staticSendTelemetryJson, ThingsBoardSized::staticSendJson, ThingsBoardSized::staticSendJsonString, ThingsBoardSized::staticClientSubscribe, ThingsBoardSized::staticClientUnsubscribe, ThingsBoardSized::staticGetClientBufferSize, ThingsBoardSized::staticSetBufferSize);
#endif // THINGSBOARD_ENABLE_STL
        }
        (void)setBufferSize(bufferSize);
        // Initalize callback.
#if THINGSBOARD_ENABLE_STL
        m_client.set_data_callback(std::bind(&ThingsBoardSized::onMQTTMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));
        m_client.set_connect_callback(std::bind(&ThingsBoardSized::Resubscribe_Topics, this));
#else
        m_client.set_data_callback(ThingsBoardSized::onStaticMQTTMessage);
        m_client.set_connect_callback(ThingsBoardSized::staticMQTTConnect);
        m_subscribedInstance = this;
#endif // THINGSBOARD_ENABLE_STL
    }

    /// @brief Gets the currently connected MQTT Client implementation as a reference.
    /// Allows for calling method directly on the client itself, not advised in normal use cases,
    /// as it might cause problems if the library expects the client to be sending / receiving data
    /// but it can not do that anymore, because it has been disconnected or certain settings were changed
    /// @return Reference to the underlying MQTT Client implementation connected to ThingsBoard
    IMQTT_Client & getClient() {
        return m_client;
    }

    /// @brief Sets the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead
    /// @param maxStackSize Maximum amount of bytes we want to allocate on the stack
    void setMaximumStackSize(size_t const & maxStackSize) {
        m_max_stack = maxStackSize;
    }

#if THINGSBOARD_ENABLE_STREAM_UTILS
    /// @brief Sets the amount of bytes that can be allocated to speed up fall back serialization with the StreamUtils class
    /// See https://github.com/bblanchon/ArduinoStreamUtils for more information on the underlying class used
    /// @param bufferingSize Amount of bytes allocated to speed up serialization
    void setBufferingSize(size_t const & bufferingSize) {
        m_buffering_size = bufferingSize;
    }
#endif // THINGSBOARD_ENABLE_STREAM_UTILS

    /// @brief Sets the size of the buffer for the underlying network client that will be used to establish the connection to ThingsBoard
    /// @param bufferSize Maximum amount of data that can be either received or sent to ThingsBoard at once, if bigger packets are received they are discarded
    /// and if we attempt to send data that is bigger, it will not be sent, the internal value can be changed later at any time with the setBufferSize() method
    /// alternatively setting THINGSBOARD_ENABLE_STREAM_UTILS to 1 allows to send arbitrary size payloads if that is done the internal buffer of the MQTT Client implementation
    /// can be theoretically set to only be as big as the biggest message we should every receive from ThingsBoard,
    /// this will mean though that all messages are sent over the StreamUtils library as long as they are bigger than the internal buffer,
    /// which needs more time than sending a message directly but has the advantage of requiring less memory.
    /// So if that is a problem on the board it might be useful to enable the THINGSBOARD_ENABLE_STREAM_UTILS option
    /// and decrease the internal buffer size of the mqtt client to what is needed to receive all MQTT messages,
    /// that size can vary but if all ThingsBoard features are used a buffer size of 256 bytes should suffice for receiving most responses.
    /// If the aforementioned feature is not enabled the buffer size might need to be much bigger though,
    /// but in that case if a message was too big to be sent the user will be informed with a message to the logger implementation.
    /// The aforementioned options can only be enabled if Arduino is used to build this library, because the StreamUtils library requires it
    /// @return Whether allocating the needed memory for the given bufferSize was successful or not
    bool setBufferSize(uint16_t bufferSize) {
        bool const result = m_client.set_buffer_size(bufferSize);
        if (!result) {
            Logger::println(UNABLE_TO_ALLOCATE_BUFFER);
        }
        return result;
    }

    /// @brief Clears all currently subscribed callbacks and unsubscribed from all
    /// currently subscribed MQTT topics, any response that will stil be received is discarded
    /// and any ongoing firmware update is aborted and will not be finished.
    /// Was previously done automatically in the connect() method, but is not done anymore,
    /// because connect() method now reconencts to all previously subscribed MQTT topics instead,
    /// therefore there is no need anymore to discard all previously subscribed callbacks and letting the user resubscribe
    void Cleanup_Subscriptions() {
        // Results are ignored, because the important part of clearing internal data structures always succeeds
        for (auto & api : m_api_implementations) {
            if (api == nullptr) {
                continue;
            }
            (void)api->Unsubscribe();
        }
    }

    /// @brief Connects to the specified ThingsBoard server over the given port as the given device.
    /// If there are still active server-side RPC or Shared Attribute subscriptions, the aforementioned topics will be resubscribed automatically.
    /// Additionally internal vectors are kept the same so any permanent subscriptions, does not need to be resubscribed by calling the appropriate subscribe methods again.
    /// @param host ThingsBoard server instance we want to connect to
    /// @param access_token Access token that connects this device with a created device on the ThingsBoard server,
    /// can be "provision", if the device creates itself instead. See https://thingsboard.io/docs/user-guide/device-provisioning/?mqttprovisioning=without#provision-device-apis for more information, default = PROV_ACCESS_TOKEN ("provision")
    /// @param port Port that will be used to establish a connection and send / receive data from ThingsBoard over, default = DEFAULT_MQTT_PORT (1883)
    /// @param client_id Client username that can be used to differentiate the user that is connecting the given device to ThingsBoard, recommended to be a unique identifier
    /// so it possible to discern which device is communicating, default = Value of passed access token
    /// @param password Client password that can be used to authenticate the user that is connecting the given device to ThingsBoard, default = nullptr
    /// @return Whether connecting to ThingsBoard was successful or not
    bool connect(char const * const host, char const * const access_token = PROV_ACCESS_TOKEN, uint16_t port = DEFAULT_MQTT_PORT, char const * const client_id = nullptr, char const * const password = nullptr) {
        if (host == nullptr) {
            return false;
        }
        m_client.set_server(host, port);
        return connectToHost(access_token, (client_id == nullptr) ? access_token : client_id, password);
    }

    /// @brief Disconnects any connection that has been established already
    void disconnect() {
        m_client.disconnect();
    }

    /// @brief Returns our current connection status to the cloud, true meaning we are connected,
    /// false meaning we have been disconnected or have not established a connection yet
    /// @return Whether the underlying MQTT Client is currently connected or not
    bool connected() {
        return m_client.connected();
    }

    /// @brief Receives / sends any outstanding messages from and to the MQTT broker.
    /// Additionally when not being able to use the ESP Timer, it updates the internal timeout timers
    /// @return Whether sending or receiving the oustanding the messages was successful or not
    bool loop() {
#if !THINGSBOARD_USE_ESP_TIMER
        for (auto & api : m_api_implementations) {
            if (api == nullptr) {
                continue;
            }
            api->loop();
        }
#endif // !THINGSBOARD_USE_ESP_TIMER
        return m_client.loop();
    }

    /// @brief Attempts to send key value pairs from custom source over the given topic to the server
    /// @param topic Topic we want to send the data over
    /// @param source JsonDocument containing our json key value pairs we want to send,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @param jsonSize Size of the data inside the source
    /// @return Whether sending the data was successful or not
    bool Send_Json(char const * const topic, JsonDocument const & source, size_t const & jsonSize) {
        // Check if allocating needed memory failed when trying to create the JsonDocument,
        // if it did the isNull() method will return true. See https://arduinojson.org/v6/api/jsonvariant/isnull/ for more information
        if (source.isNull()) {
            Logger::println(UNABLE_TO_ALLOCATE_JSON);
            return false;
        }
        // Check if inserting any of the internal values failed because the JsonDocument was too small,
        // if it did the overflowed() method will return true. See https://arduinojson.org/v6/api/jsondocument/overflowed/ for more information
        if (source.overflowed()) {
            Logger::println(JSON_SIZE_TO_SMALL);
            return false;
        }
#if !THINGSBOARD_ENABLE_DYNAMIC
        size_t const amount = source.size();
        if (MaxFieldsAmount < amount) {
            Logger::printfln(TOO_MANY_JSON_FIELDS, amount, MaxFieldsAmount);
            return false;
        }
#endif // !THINGSBOARD_ENABLE_DYNAMIC
        bool result = false;

#if THINGSBOARD_ENABLE_STREAM_UTILS
        // Check if the size of the given message would be too big for the actual client,
        // if it is utilize the serialize json work around, so that the internal client buffer can be circumvented
        if (m_client.get_buffer_size() < jsonSize)  {
#if THINGSBOARD_ENABLE_DEBUG
            Logger::printfln(SEND_MESSAGE, topic, SEND_SERIALIZED);
#endif // THINGSBOARD_ENABLE_DEBUG
            result = Serialize_Json(topic, source, jsonSize - 1);
        }
        // Check if the remaining stack size of the current task would overflow the stack,
        // if it would allocate the memory on the heap instead to ensure no stack overflow occurs
        else
#endif // THINGSBOARD_ENABLE_STREAM_UTILS
        if (getMaximumStackSize() < jsonSize) {
            char* json = new char[jsonSize]();
            if (serializeJson(source, json, jsonSize) < jsonSize - 1) {
                Logger::println(UNABLE_TO_SERIALIZE_JSON);
            }
            else {
                result = Send_Json_String(topic, json);
            }
            // Ensure to actually delete the memory placed onto the heap, to make sure we do not create a memory leak
            // and set the pointer to null so we do not have a dangling reference.
            delete[] json;
            json = nullptr;
        }
        else {
            char json[jsonSize] = {};
            if (serializeJson(source, json, jsonSize) < jsonSize - 1) {
                Logger::println(UNABLE_TO_SERIALIZE_JSON);
                return result;
            }
            result = Send_Json_String(topic, json);
        }

        return result;
    }

    /// @brief Attempts to send custom json string over the given topic to the server
    /// @param topic Topic we want to send the data over
    /// @param json String containing our json key value pairs we want to attempt to send
    /// @return Whether sending the data was successful or not
    bool Send_Json_String(char const * const topic, char const * const json) {
        if (json == nullptr) {
            return false;
        }

        uint16_t currentBufferSize = m_client.get_buffer_size();
        size_t const jsonSize = strlen(json);

        if (currentBufferSize < jsonSize) {
            Logger::printfln(INVALID_BUFFER_SIZE, currentBufferSize, jsonSize);
            return false;
        }

#if THINGSBOARD_ENABLE_DEBUG
        Logger::printfln(SEND_MESSAGE, topic, json);
#endif // THINGSBOARD_ENABLE_DEBUG
        return m_client.publish(topic, reinterpret_cast<uint8_t const *>(json), jsonSize);
    }

    /// @brief Copies a non-owning pointer to the given API implementation, into the local data container.
    /// Ensure the actual variable is kept alive for as long as the instance of this class
    /// @param api Additional API that we want to be handled
    void Subscribe_API_Implementation(API_Implementation & api) {
#if THINGSBOARD_ENABLE_STL
        api.Set_Client_Callbacks(std::bind(&ThingsBoardSized::Subscribe_API_Implementation, this, std::placeholders::_1), std::bind(&ThingsBoardSized::sendTelemetryJson, this, std::placeholders::_1, std::placeholders::_2), std::bind(&ThingsBoardSized::Send_Json, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3), std::bind(&ThingsBoardSized::Send_Json_String, this, std::placeholders::_1, std::placeholders::_2), std::bind(&ThingsBoardSized::clientSubscribe, this, std::placeholders::_1), std::bind(&ThingsBoardSized::clientUnsubscribe, this, std::placeholders::_1), std::bind(&ThingsBoardSized::getClientBufferSize, this), std::bind(&ThingsBoardSized::setBufferSize, this, std::placeholders::_1));
#else
        api.Set_Client_Callbacks(ThingsBoardSized::staticSubscribeImplementation, ThingsBoardSized::staticSendTelemetryJson, ThingsBoardSized::staticSendJson, ThingsBoardSized::staticSendJsonString, ThingsBoardSized::staticClientSubscribe, ThingsBoardSized::staticClientUnsubscribe, ThingsBoardSized::staticGetClientBufferSize, ThingsBoardSized::staticSetBufferSize);
#endif // THINGSBOARD_ENABLE_STL
        m_api_implementations.push_back(&api);
    }

    //----------------------------------------------------------------------------
    // Claiming API

    /// @brief Sends a claiming request for the given device, allowing any given user on the cloud to assign the device as their own (claim),
    /// as long as they enter the given device name and secret key in the given amount of time.
    /// Optionally a secret key can be passed or be left empty (cloud will allow any user to claim the device for the given amount of time).
    /// See https://thingsboard.io/docs/user-guide/claiming-devices/ for more information
    /// @param secretKey Password the user additionaly to the device name needs to enter to claim it as their own,
    /// pass nullptr or an empty string if the user should be able to claim the device without any password
    /// @param durationMs Total time in milliseconds the user has to claim their device as their own
    /// @return Whether sending the claiming request was successful or not
    bool Claim_Request(char const * const secretKey, size_t const & durationMs) {
        StaticJsonDocument<JSON_OBJECT_SIZE(2)> requestBuffer;

        if (!Helper::stringIsNullorEmpty(secretKey)) {
            requestBuffer[SECRET_KEY] = secretKey;
        }
        requestBuffer[DURATION_KEY] = durationMs;

        size_t const objectSize = Helper::Measure_Json(requestBuffer);
        return Send_Json(CLAIM_TOPIC, requestBuffer, objectSize);
    }

    //----------------------------------------------------------------------------
    // Telemetry API

    /// @brief Attempts to send telemetry data with the given key and value of the given type.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @tparam T Type of the passed value
    /// @param key Key of the key value pair we want to send
    /// @param value Value of the key value pair we want to send
    /// @return Whether sending the data was successful or not
    template<typename T>
    bool sendTelemetryData(char const * const key, T const & value) {
        return sendKeyValue(key, value);
    }

    /// @brief Attempts to send aggregated telemetry data, expects iterators to a container containing Telemetry class instances.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @tparam InputIterator Class that points to the begin and end iterator
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether sending the aggregated telemetry data was successful or not
    template<typename InputIterator>
    bool sendTelemetry(InputIterator const & first, InputIterator const & last) {
        return sendDataArray(first, last, true);
    }

    /// @brief Attempts to send custom json telemetry string.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @param json String containing our json key value pairs we want to attempt to send
    /// @return Whether sending the data was successful or not
    bool sendTelemtryString(char const * const json) {
        return Send_Json_String(TELEMETRY_TOPIC, json);
    }

    /// @brief Attempts to send telemetry key value pairs from custom source to the server.
    /// See https://thingsboard.io/docs/user-guide/telemetry/ for more information
    /// @param source JsonDocument containing our json key value pairs we want to send,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @param jsonSize Size of the data inside the source
    /// @return Whether sending the data was successful or not
    bool sendTelemetryJson(JsonDocument const & source, size_t const & jsonSize) {
        return Send_Json(TELEMETRY_TOPIC, source, jsonSize);
    }

    //----------------------------------------------------------------------------
    // Attribute API

    /// @brief Attempts to send attribute data with the given key and value of the given type.
    /// See https://thingsboard.io/docs/user-guide/attributes/ for more information
    /// @tparam T Type of the passed value
    /// @param key Key of the key value pair we want to send
    /// @param value Value of the key value pair we want to send
    /// @return Whether sending the data was successful or not
    template<typename T>
    bool sendAttributeData(char const * const key, T const & value) {
        return sendKeyValue(key, value, false);
    }

    /// @brief Attempts to send aggregated attribute data, expects iterators to a container containing Attribute class instances.
    /// See https://thingsboard.io/docs/user-guide/attributes/ for more information
    /// @tparam InputIterator Class that points to the begin and end iterator
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @return Whether sending the aggregated attribute data was successful or not
    template<typename InputIterator>
    bool sendAttributes(InputIterator const & first, InputIterator const & last) {
        return sendDataArray(first, last, false);
    }

    /// @brief Attempts to send custom json attribute string.
    /// See https://thingsboard.io/docs/user-guide/attributes/ for more information
    /// @param json String containing our json key value pairs we want to attempt to send
    /// @return Whether sending the data was successful or not
    bool sendAttributeString(char const * const json) {
        return Send_Json_String(ATTRIBUTE_TOPIC, json);
    }

    /// @brief Attempts to send attribute key value pairs from custom source to the server.
    /// See https://thingsboard.io/docs/user-guide/attributes/ for more information
    /// @param source JsonDocument containing our json key value pairs we want to send,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @param jsonSize Size of the data inside the source
    /// @return Whether sending the data was successful or not
    bool sendAttributeJson(JsonDocument const & source, size_t const & jsonSize) {
        return Send_Json(ATTRIBUTE_TOPIC, source, jsonSize);
    }

  private:
#if THINGSBOARD_ENABLE_STREAM_UTILS
    /// @brief Serialize the custom attribute source into the underlying client.
    /// Sends the given bytes to the client without requiring any temporary buffer at the cost of hugely increased send times
    /// @param topic Topic we want to send the data over
    /// @param source JsonDocument containing our json key value pairs we want to send,
    /// is checked before usage for any possible occuring internal errors. See https://arduinojson.org/v6/api/jsondocument/ for more information
    /// @param jsonSize Size of the data inside the source
    /// @return Whether sending the data was successful or not
    bool Serialize_Json(char const * const topic, JsonDocument const & source, size_t const & jsonSize) {
        if (!m_client.begin_publish(topic, jsonSize)) {
            Logger::println(UNABLE_TO_SERIALIZE_JSON);
            return false;
        }
        BufferingPrint buffered_print(m_client, getBufferingSize());
        size_t const bytes_serialized = serializeJson(source, buffered_print);
        if (bytes_serialized < jsonSize) {
            Logger::println(UNABLE_TO_SERIALIZE_JSON);
            return false;
        }
        buffered_print.flush();
        return m_client.end_publish();
    }
#endif // THINGSBOARD_ENABLE_STREAM_UTILS

    /// @brief Returns the maximum amount of bytes that we want to allocate on the stack, before the memory is allocated on the heap instead
    /// @return Maximum amount of bytes we want to allocate on the stack
    size_t const & getMaximumStackSize() const {
        return m_max_stack;
    }

    /// @brief Returns the current buffer size of the underlying client interface
    /// @return Current internal buffer size
    uint16_t getClientBufferSize() {
        return m_client.get_buffer_size();
    }

    /// @brief Subscribes the given topic with the underlying client interface
    /// @param topic Topic that should be subscribed
    /// @return Whether subscribing was successfull or not
    bool clientSubscribe(char const * const topic) {
        return m_client.subscribe(topic);
    }

    /// @brief Unsubscribes the given topic with the underlying client interface
    /// @param topic Topic that should be unsubscribed
    /// @return Whether unsubscribing was successfull or not
    bool clientUnsubscribe(char const * const topic) {
        return m_client.unsubscribe(topic);
    }

#if THINGSBOARD_ENABLE_STREAM_UTILS
    /// @brief Returns the amount of bytes that can be allocated to speed up fall back serialization with the StreamUtils class
    /// See https://github.com/bblanchon/ArduinoStreamUtils for more information on the underlying class used
    /// @return Amount of bytes allocated to speed up serialization
    size_t const & getBufferingSize() const {
      return m_buffering_size;
    }
#endif // THINGSBOARD_ENABLE_STREAM_UTILS

    /// @brief Connects to the previously set ThingsBoard server, as the given client with the given access token
    /// @param access_token Access token that connects this device with a created device on the ThingsBoard server,
    /// can be "provision", if the device creates itself instead
    /// @param client_id Client username that can be used to differentiate the user that is connecting the given device to ThingsBoard
    /// @param password Client password that can be used to authenticate the user that is connecting the given device to ThingsBoard
    /// @return Whether connecting to ThingsBoard was successful or not
    bool connectToHost(char const * const access_token, char const * const client_id, char const * const password) {
        bool const connection_result = m_client.connect(client_id, access_token, password);
        if (!connection_result) {
            Logger::println(CONNECT_FAILED);
        }
        return connection_result;
    }

    /// @brief Resubscribes to topics that establish a permanent connection with MQTT, meaning they may receive more than one event over their lifetime,
    /// whereas other events that are only ever called once and then deleted after they have been handled are not resubscribed.
    /// Only the topics that establish a permanent connection are resubscribed, because all not yet received data is discard on the MQTT broker,
    // once we establish a connection again. This is the case because we connect with the cleanSession attribute set to true.
    // Therefore we can also clear the buffer of all non-permanent topics.
    void Resubscribe_Topics() {
        // Results are ignored, because the important part of clearing internal data structures always succeeds
        for (auto & api : m_api_implementations) {
            if (api == nullptr) {
                continue;
            }
            (void)api->Resubscribe_Topic();
        }
    }

    /// @brief Attempts to send a single key-value pair with the given key and value of the given type
    /// @tparam T Type of the passed value
    /// @param key Key of the key value pair we want to send
    /// @param value Value of the key value pair we want to send
    /// @param telemetry Whether the data we want to send should be sent as an attribute or telemetry data value
    /// @return Whether sending the data was successful or not
    template<typename T>
    bool sendKeyValue(char const * const key, T const & value, bool telemetry = true) {
        const Telemetry t(key, value);
        if (t.IsEmpty()) {
            return false;
        }

        StaticJsonDocument<JSON_OBJECT_SIZE(1)> jsonBuffer;
        if (!t.SerializeKeyValue(jsonBuffer)) {
            Logger::println(UNABLE_TO_SERIALIZE);
            return false;
        }
        return telemetry ? sendTelemetryJson(jsonBuffer, Helper::Measure_Json(jsonBuffer)) : sendAttributeJson(jsonBuffer, Helper::Measure_Json(jsonBuffer));
    }

    /// @brief Attempts to send aggregated attribute or telemetry data
    /// @tparam InputIterator Class that points to the begin and end iterator
    /// of the given data container, allows for using / passing either std::vector or std::array.
    /// See https://en.cppreference.com/w/cpp/iterator/input_iterator for more information on the requirements of the iterator
    /// @param first Iterator pointing to the first element in the data container
    /// @param last Iterator pointing to the end of the data container (last element + 1)
    /// @param telemetry Whether the data we want to send should be sent over the attribute or telemtry topic
    /// @return Whether sending the aggregated data was successful or not
    template<typename InputIterator>
    bool sendDataArray(InputIterator const & first, InputIterator const & last, bool telemetry) {
#if THINGSBOARD_ENABLE_DYNAMIC
        // String are char const * and therefore stored as a pointer --> zero copy, meaning the size for the strings is 0 bytes,
        // Data structure size depends on the amount of key value pairs passed.
        // See https://arduinojson.org/v6/assistant/ for more information on the needed size for the JsonDocument
        size_t const size = Helper::distance(first, last);
        TBJsonDocument jsonBuffer(JSON_OBJECT_SIZE(size));
#else
        StaticJsonDocument<JSON_OBJECT_SIZE(MaxFieldsAmount)> jsonBuffer;
#endif // THINGSBOARD_ENABLE_DYNAMIC

        for (auto it = first; it != last; ++it) {
            auto const & data = *it;
            if (!data.SerializeKeyValue(jsonBuffer)) {
                Logger::println(UNABLE_TO_SERIALIZE);
                return false;
            }
        }
        return telemetry ? sendTelemetryJson(jsonBuffer, Helper::Measure_Json(jsonBuffer)) : sendAttributeJson(jsonBuffer, Helper::Measure_Json(jsonBuffer));
    }

    /// @brief MQTT callback that will be called if a publish message is received from the server
    /// @param topic Previously subscribed topic, we got the response over 
    /// @param payload Payload that was sent over the cloud and received over the given topic
    /// @param length Total length of the received payload
    void onMQTTMessage(char * topic, uint8_t * payload, unsigned int length) {
#if THINGSBOARD_ENABLE_DEBUG
        Logger::printfln(RECEIVE_MESSAGE, topic);
#endif // THINGSBOARD_ENABLE_DEBUG

        for (auto & api : m_api_implementations) {
            if (api == nullptr || api->Get_Process_Type() != API_Process_Type::RAW || strncmp(topic, api->Get_Response_Topic_String(), strlen(topic)) != 0) {
                continue;
            }
            // Check if the remaining stack size of the current task would overflow the stack,
            // if it would allocate the memory on the heap instead to ensure no stack overflow occurs.
            if (getMaximumStackSize() < length) {
                uint8_t* binary = new uint8_t[length]();
                (void)memcpy(binary, payload, length);
                api->Process_Response(topic, binary, length);
                // Ensure to actually delete the memory placed onto the heap, to make sure we do not create a memory leak
                // and set the pointer to null so we do not have a dangling reference.
                delete[] binary;
                binary = nullptr;
            }
            else {
                uint8_t binary[length] = {};
                (void)memcpy(binary, payload, length);
                api->Process_Response(topic, binary, length);
            }
            return;
        }

#if THINGSBOARD_ENABLE_DYNAMIC
        // Buffer that we deserialize is writeable and not read only --> zero copy, meaning the size for the data is 0 bytes,
        // Data structure size depends on the amount of key value pairs received.
        // See https://arduinojson.org/v6/assistant/ for more information on the needed size for the JsonDocument
        TBJsonDocument jsonBuffer(JSON_OBJECT_SIZE(Helper::getOccurences(reinterpret_cast<char *>(payload), ':')));
#else
        StaticJsonDocument<JSON_OBJECT_SIZE(MaxFieldsAmount)> jsonBuffer;
#endif // THINGSBOARD_ENABLE_DYNAMIC

        // The deserializeJson method we use, can use the zero copy mode because a writeable input was passed,
        // if that were not the case the needed allocated memory would drastically increase, because the keys would need to be copied as well.
        // See https://arduinojson.org/v6/doc/deserialization/ for more info on ArduinoJson deserialization
        DeserializationError const error = deserializeJson(jsonBuffer, payload, length);
        if (error) {
            Logger::printfln(UNABLE_TO_DE_SERIALIZE_JSON, error.c_str());
            return;
        }
        // .as() is used instead of .to(), because it is meant to cast the JsonDocument to the given type,
        // but it does not change the actual content of the JsonDocument, we don't want that because it contains content
        // and .to() would result in the data being cleared ()"null"), instead .as() which allows accessing the data over a JsonObjectConst instead
        JsonObjectConst data = jsonBuffer.template as<JsonObjectConst>();

        for (auto & api : m_api_implementations) {
            if (api == nullptr || api->Get_Process_Type() != API_Process_Type::JSON || strncmp(topic, api->Get_Response_Topic_String(), strlen(topic)) != 0) {
                continue;
            }
            api->Process_Json_Response(topic, data);
        }
    }

#if !THINGSBOARD_ENABLE_STL
    static void onStaticMQTTMessage(char * topic, uint8_t * payload, unsigned int length) {
        if (m_subscribedInstance == nullptr) {
            return;
        }
        m_subscribedInstance->onMQTTMessage(topic, payload, length);
    }

    static void staticMQTTConnect() {
        if (m_subscribedInstance == nullptr) {
            return;
        }
        m_subscribedInstance->Resubscribe_Topics();
    }

    static void staticSubscribeImplementation(API_Implementation & api) {
        if (m_subscribedInstance == nullptr) {
            return;
        }
        m_subscribedInstance->Subscribe_API_Implementation(api);
    }

    static bool staticSendTelemetryJson(JsonDocument const & source, size_t const & jsonSize) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->sendTelemetryJson(source, jsonSize);
    }

    static bool staticSendJson(char const * const topic, JsonDocument const & source, size_t const & jsonSize) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->Send_Json(topic, source, jsonSize);
    }

    static bool staticSendJsonString(char const * const topic, char const * const json) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->Send_Json_String(topic, json);
    }

    static bool staticClientSubscribe(char const * const topic) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->clientSubscribe(topic);
    }

    static bool staticClientUnsubscribe(char const * const topic) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->clientUnsubscribe(topic);
    }

    static uint16_t staticGetClientBufferSize() {
        if (m_subscribedInstance == nullptr) {
            return 0U;
        }
        return m_subscribedInstance->getClientBufferSize();
    }

    static bool staticSetBufferSize(uint16_t bufferSize) {
        if (m_subscribedInstance == nullptr) {
            return false;
        }
        return m_subscribedInstance->setBufferSize(bufferSize);
    }

    // PubSub client cannot call a instanced method when message arrives on subscribed topic.
    // Only free-standing function is allowed.
    // To be able to forward event to an instance, rather than to a function, this pointer exists.
    static ThingsBoardSized *m_subscribedInstance;
#endif // !THINGSBOARD_ENABLE_STL

    IMQTT_Client&                                 m_client;              // MQTT client instance.
    size_t                                        m_max_stack;           // Maximum stack size we allocate at once.
#if THINGSBOARD_ENABLE_STREAM_UTILS
    size_t                                        m_buffering_size;      // Buffering size used to serialize directly into client.
#endif // THINGSBOARD_ENABLE_STREAM_UTILS
#if !THINGSBOARD_ENABLE_DYNAMIC
    Array<API_Implementation*, MaxEndpointsAmount> m_api_implementations; // Can hold a pointer to all possible API implementations (Server side RPC, Client side RPC, Shared attribute update, Client-side or shared attribute request, Provision)   
#else
    Vector<API_Implementation*>                    m_api_implementations; // Can hold a pointer to all  possible API implementations (Server side RPC, Client side RPC, Shared attribute update, Client-side or shared attribute request, Provision)   
#endif // !THINGSBOARD_ENABLE_DYNAMIC                
};

#if !THINGSBOARD_ENABLE_STL
#if !THINGSBOARD_ENABLE_DYNAMIC
template<size_t MaxFieldsAmount, size_t MaxEndpointsAmount, typename Logger>
ThingsBoardSized<MaxFieldsAmount, MaxEndpointsAmount, Logger> *ThingsBoardSized<MaxFieldsAmount, MaxEndpointsAmount, Logger>::m_subscribedInstance = nullptr;
#else
template<typename Logger>
ThingsBoardSized<Logger> *ThingsBoardSized<Logger>::m_subscribedInstance = nullptr;
#endif // !THINGSBOARD_ENABLE_DYNAMIC
#endif // !THINGSBOARD_ENABLE_STL

using ThingsBoard = ThingsBoardSized<>;

#endif // ThingsBoard_h
