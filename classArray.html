<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Array&lt; T, Capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.15.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classArray-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Array&lt; T, Capacity &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Replacement data container for boards that do not support the C++ STL and therefore do not have the std::array class.  
 <a href="classArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8h_source.html">Array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Array&lt; T, Capacity &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classArray__inherit__graph.svg" width="564" height="592"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a669360910e01b93461e5f0a1ae8c2875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a669360910e01b93461e5f0a1ae8c2875">value_type</a> = T</td></tr>
<tr class="separator:a669360910e01b93461e5f0a1ae8c2875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a43a8bd1b34a623427eb5c0b0afa6d91c">Array</a> (void)=default</td></tr>
<tr class="memdesc:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classArray.html#a43a8bd1b34a623427eb5c0b0afa6d91c">More...</a><br /></td></tr>
<tr class="separator:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6ae3814a7305132965b80d8a412b53"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a5f6ae3814a7305132965b80d8a412b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#a5f6ae3814a7305132965b80d8a412b53">Array</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:a5f6ae3814a7305132965b80d8a412b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data between the first and last iterator.  <a href="classArray.html#a5f6ae3814a7305132965b80d8a412b53">More...</a><br /></td></tr>
<tr class="separator:a5f6ae3814a7305132965b80d8a412b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f496eed398068830eba5cc17aba73"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ae75f496eed398068830eba5cc17aba73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#ae75f496eed398068830eba5cc17aba73">Array</a> (Container const &amp;container)</td></tr>
<tr class="memdesc:ae75f496eed398068830eba5cc17aba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data from the given container.  <a href="classArray.html#ae75f496eed398068830eba5cc17aba73">More...</a><br /></td></tr>
<tr class="separator:ae75f496eed398068830eba5cc17aba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40e50a09e479be6195d5306bbb5a515"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab40e50a09e479be6195d5306bbb5a515"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#ab40e50a09e479be6195d5306bbb5a515">assign</a> (InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:ab40e50a09e479be6195d5306bbb5a515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data between the first and last iterator.  <a href="classArray.html#ab40e50a09e479be6195d5306bbb5a515">More...</a><br /></td></tr>
<tr class="separator:ab40e50a09e479be6195d5306bbb5a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b8ceaa3622e9bf43d28f02cbb11b2f"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a47b8ceaa3622e9bf43d28f02cbb11b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#a47b8ceaa3622e9bf43d28f02cbb11b2f">assign</a> (Container const &amp;container)</td></tr>
<tr class="memdesc:a47b8ceaa3622e9bf43d28f02cbb11b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data from the given container.  <a href="classArray.html#a47b8ceaa3622e9bf43d28f02cbb11b2f">More...</a><br /></td></tr>
<tr class="separator:a47b8ceaa3622e9bf43d28f02cbb11b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b56c91a89d22a430223dd43664b7def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a8b56c91a89d22a430223dd43664b7def">empty</a> () const</td></tr>
<tr class="memdesc:a8b56c91a89d22a430223dd43664b7def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are still any element in the underlying data container.  <a href="classArray.html#a8b56c91a89d22a430223dd43664b7def">More...</a><br /></td></tr>
<tr class="separator:a8b56c91a89d22a430223dd43664b7def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f0f4218cf304a7bd3578a5b02bec3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a437f0f4218cf304a7bd3578a5b02bec3">size</a> () const</td></tr>
<tr class="memdesc:a437f0f4218cf304a7bd3578a5b02bec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current amount of elements in the underlying data container.  <a href="classArray.html#a437f0f4218cf304a7bd3578a5b02bec3">More...</a><br /></td></tr>
<tr class="separator:a437f0f4218cf304a7bd3578a5b02bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd2287c4333ac0de1f15ebfb5eb16a0"><td class="memItemLeft" align="right" valign="top">size_t constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a2bd2287c4333ac0de1f15ebfb5eb16a0">capacity</a> () const</td></tr>
<tr class="memdesc:a2bd2287c4333ac0de1f15ebfb5eb16a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum amount of elements that can currently be stored in the underlying data container.  <a href="classArray.html#a2bd2287c4333ac0de1f15ebfb5eb16a0">More...</a><br /></td></tr>
<tr class="separator:a2bd2287c4333ac0de1f15ebfb5eb16a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba298d705a7b1b98c237c7e077079c6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6">begin</a> ()</td></tr>
<tr class="memdesc:acba298d705a7b1b98c237c7e077079c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to the first element of the underlying data container.  <a href="classArray.html#acba298d705a7b1b98c237c7e077079c6">More...</a><br /></td></tr>
<tr class="separator:acba298d705a7b1b98c237c7e077079c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649850b709a4192a55176a58aa5a0e50"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a649850b709a4192a55176a58aa5a0e50">begin</a> () const</td></tr>
<tr class="memdesc:a649850b709a4192a55176a58aa5a0e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the underlying data container.  <a href="classArray.html#a649850b709a4192a55176a58aa5a0e50">More...</a><br /></td></tr>
<tr class="separator:a649850b709a4192a55176a58aa5a0e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb279b27f54a2530575b51da33a15e0a"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aeb279b27f54a2530575b51da33a15e0a">cbegin</a> () const</td></tr>
<tr class="memdesc:aeb279b27f54a2530575b51da33a15e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the underlying data container.  <a href="classArray.html#aeb279b27f54a2530575b51da33a15e0a">More...</a><br /></td></tr>
<tr class="separator:aeb279b27f54a2530575b51da33a15e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09326a0aea557d080f856d2d02734a54"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a09326a0aea557d080f856d2d02734a54">back</a> ()</td></tr>
<tr class="memdesc:a09326a0aea557d080f856d2d02734a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element of the vector.  <a href="classArray.html#a09326a0aea557d080f856d2d02734a54">More...</a><br /></td></tr>
<tr class="separator:a09326a0aea557d080f856d2d02734a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d">end</a> ()</td></tr>
<tr class="memdesc:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a iterator to one-past-the-end element of the underlying data container.  <a href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d">More...</a><br /></td></tr>
<tr class="separator:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233404f5a66c7c2d434f60911bdccdd8"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a233404f5a66c7c2d434f60911bdccdd8">end</a> () const</td></tr>
<tr class="memdesc:a233404f5a66c7c2d434f60911bdccdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constantiterator to one-past-the-end element of the underlying data container.  <a href="classArray.html#a233404f5a66c7c2d434f60911bdccdd8">More...</a><br /></td></tr>
<tr class="separator:a233404f5a66c7c2d434f60911bdccdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416f0777cffcd9cede627aaff0bbe6bb"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a416f0777cffcd9cede627aaff0bbe6bb">cend</a> () const</td></tr>
<tr class="memdesc:a416f0777cffcd9cede627aaff0bbe6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to one-past-the-end element of the underlying data container.  <a href="classArray.html#a416f0777cffcd9cede627aaff0bbe6bb">More...</a><br /></td></tr>
<tr class="separator:a416f0777cffcd9cede627aaff0bbe6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8a222828c457b826642c8faa7d8feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a7f8a222828c457b826642c8faa7d8feb">push_back</a> (T const &amp;element)</td></tr>
<tr class="memdesc:a7f8a222828c457b826642c8faa7d8feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element at the end of the underlying data container, if the interal data structure is full already then this method will assert and stop the application. Because if we do not we could cause an out of bounds write, which could possibly overwrite other memory. Causing hard to debug issues, therefore this behaviour is not allowed in the first place.  <a href="classArray.html#a7f8a222828c457b826642c8faa7d8feb">More...</a><br /></td></tr>
<tr class="separator:a7f8a222828c457b826642c8faa7d8feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744e1cc85b9838d21c265d32d4ac3268"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a744e1cc85b9838d21c265d32d4ac3268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#a744e1cc85b9838d21c265d32d4ac3268">insert</a> (T const *position, InputIterator const &amp;first, InputIterator const &amp;last)</td></tr>
<tr class="memdesc:a744e1cc85b9838d21c265d32d4ac3268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element, meaning if the initally allocated size if not big enough to hold all elements, then this method will simply not insert those elements instead.  <a href="classArray.html#a744e1cc85b9838d21c265d32d4ac3268">More...</a><br /></td></tr>
<tr class="separator:a744e1cc85b9838d21c265d32d4ac3268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27c4c317e350e6654d5732f54b42f51"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af27c4c317e350e6654d5732f54b42f51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classArray.html#af27c4c317e350e6654d5732f54b42f51">erase</a> (InputIterator const &amp;position)</td></tr>
<tr class="memdesc:af27c4c317e350e6654d5732f54b42f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at the given position, has to move all element one to the left if the index is not at the end of the array.  <a href="classArray.html#af27c4c317e350e6654d5732f54b42f51">More...</a><br /></td></tr>
<tr class="separator:af27c4c317e350e6654d5732f54b42f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81478550622ac8741a50d103c40237ac"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a81478550622ac8741a50d103c40237ac">at</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a81478550622ac8741a50d103c40237ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location.  <a href="classArray.html#a81478550622ac8741a50d103c40237ac">More...</a><br /></td></tr>
<tr class="separator:a81478550622ac8741a50d103c40237ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a683e5ca9ab0b009eb1880fa20e7fca1e">operator[]</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classArray.html#a683e5ca9ab0b009eb1880fa20e7fca1e">More...</a><br /></td></tr>
<tr class="separator:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c0d465703091b52d7ef1f51ab872be"><td class="memItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aa9c0d465703091b52d7ef1f51ab872be">operator[]</a> (size_t const &amp;index) const</td></tr>
<tr class="memdesc:aa9c0d465703091b52d7ef1f51ab872be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classArray.html#aa9c0d465703091b52d7ef1f51ab872be">More...</a><br /></td></tr>
<tr class="separator:aa9c0d465703091b52d7ef1f51ab872be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee8f81241ce57ee65a3d979b807f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a77ee8f81241ce57ee65a3d979b807f56">clear</a> ()</td></tr>
<tr class="memdesc:a77ee8f81241ce57ee65a3d979b807f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor.  <a href="classArray.html#a77ee8f81241ce57ee65a3d979b807f56">More...</a><br /></td></tr>
<tr class="separator:a77ee8f81241ce57ee65a3d979b807f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, size_t Capacity&gt;<br />
class Array&lt; T, Capacity &gt;</div><p >Replacement data container for boards that do not support the C++ STL and therefore do not have the std::array class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the underlying data the list should point too. </td></tr>
    <tr><td class="paramname">Capacity</td><td>Amount of elements that can be saved into the underlying data structure allows to wrap a simple c-array and allocate it on the stack. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a669360910e01b93461e5f0a1ae8c2875" name="a669360910e01b93461e5f0a1ae8c2875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669360910e01b93461e5f0a1ae8c2875">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43a8bd1b34a623427eb5c0b0afa6d91c" name="a43a8bd1b34a623427eb5c0b0afa6d91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a8bd1b34a623427eb5c0b0afa6d91c">&#9670;&#160;</a></span>Array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;<a class="el" href="classArray.html">::Array</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a5f6ae3814a7305132965b80d8a412b53" name="a5f6ae3814a7305132965b80d8a412b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6ae3814a7305132965b80d8a412b53">&#9670;&#160;</a></span>Array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;<a class="el" href="classArray.html">::Array</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data between the first and last iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae75f496eed398068830eba5cc17aba73" name="ae75f496eed398068830eba5cc17aba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75f496eed398068830eba5cc17aba73">&#9670;&#160;</a></span>Array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;<a class="el" href="classArray.html">::Array</a> </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data from the given container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Class that contains the actual data we want to copy into our internal data container, requires access to a <a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6" title="Returns a iterator to the first element of the underlying data container.">begin()</a> and <a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d" title="Returns a iterator to one-past-the-end element of the underlying data container.">end()</a> method, that point to the first element and one past the last element we want to copy respectively. Both methods need to return an InputIterator, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Data container with <a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6" title="Returns a iterator to the first element of the underlying data container.">begin()</a> and <a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d" title="Returns a iterator to one-past-the-end element of the underlying data container.">end()</a> method that we want to copy fully into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47b8ceaa3622e9bf43d28f02cbb11b2f" name="a47b8ceaa3622e9bf43d28f02cbb11b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b8ceaa3622e9bf43d28f02cbb11b2f">&#9670;&#160;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data from the given container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Class that contains the actual data we want to copy into our internal data container, requires access to a <a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6" title="Returns a iterator to the first element of the underlying data container.">begin()</a> and <a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d" title="Returns a iterator to one-past-the-end element of the underlying data container.">end()</a> method, that point to the first element and one past the last element we want to copy respectively. Both methods need to return an InputIterator, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Data container with <a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6" title="Returns a iterator to the first element of the underlying data container.">begin()</a> and <a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d" title="Returns a iterator to one-past-the-end element of the underlying data container.">end()</a> method that we want to copy fully into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab40e50a09e479be6195d5306bbb5a515" name="ab40e50a09e479be6195d5306bbb5a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40e50a09e479be6195d5306bbb5a515">&#9670;&#160;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that allows compatibility with std::vector, simply forwards call to internal insert method and copies all data between the first and last iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81478550622ac8741a50d103c40237ac" name="a81478550622ac8741a50d103c40237ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81478550622ac8741a50d103c40237ac">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09326a0aea557d080f856d2d02734a54" name="a09326a0aea557d080f856d2d02734a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09326a0aea557d080f856d2d02734a54">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element of the vector </dd></dl>

</div>
</div>
<a id="acba298d705a7b1b98c237c7e077079c6" name="acba298d705a7b1b98c237c7e077079c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba298d705a7b1b98c237c7e077079c6">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to the first element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element of the underlying data container </dd></dl>

</div>
</div>
<a id="a649850b709a4192a55176a58aa5a0e50" name="a649850b709a4192a55176a58aa5a0e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649850b709a4192a55176a58aa5a0e50">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to the first element of the underlying data container </dd></dl>

</div>
</div>
<a id="a2bd2287c4333ac0de1f15ebfb5eb16a0" name="a2bd2287c4333ac0de1f15ebfb5eb16a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd2287c4333ac0de1f15ebfb5eb16a0">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t constexpr <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum amount of elements that can currently be stored in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum amount of items that can currently be stored in the underlying data container </dd></dl>

</div>
</div>
<a id="aeb279b27f54a2530575b51da33a15e0a" name="aeb279b27f54a2530575b51da33a15e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb279b27f54a2530575b51da33a15e0a">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to the first element of the underlying data container </dd></dl>

</div>
</div>
<a id="a416f0777cffcd9cede627aaff0bbe6bb" name="a416f0777cffcd9cede627aaff0bbe6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416f0777cffcd9cede627aaff0bbe6bb">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to one-past-the-end element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to one-past-the-end element of the underlying data container </dd></dl>

</div>
</div>
<a id="a77ee8f81241ce57ee65a3d979b807f56" name="a77ee8f81241ce57ee65a3d979b807f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ee8f81241ce57ee65a3d979b807f56">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor. </p>

</div>
</div>
<a id="a8b56c91a89d22a430223dd43664b7def" name="a8b56c91a89d22a430223dd43664b7def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b56c91a89d22a430223dd43664b7def">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there are still any element in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the underlying data container is empty or not </dd></dl>

</div>
</div>
<a id="ae0422f0975fa4bd276ef88866ec6ca1d" name="ae0422f0975fa4bd276ef88866ec6ca1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0422f0975fa4bd276ef88866ec6ca1d">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a iterator to one-past-the-end element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to one-past-the-end element of the underlying data container </dd></dl>

</div>
</div>
<a id="a233404f5a66c7c2d434f60911bdccdd8" name="a233404f5a66c7c2d434f60911bdccdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233404f5a66c7c2d434f60911bdccdd8">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constantiterator to one-past-the-end element of the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator pointing to one-past-the-end element of the underlying data container </dd></dl>

</div>
</div>
<a id="af27c4c317e350e6654d5732f54b42f51" name="af27c4c317e350e6654d5732f54b42f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27c4c317e350e6654d5732f54b42f51">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at the given position, has to move all element one to the left if the index is not at the end of the array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to the element, that should be removed from the underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a744e1cc85b9838d21c265d32d4ac3268" name="a744e1cc85b9838d21c265d32d4ac3268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744e1cc85b9838d21c265d32d4ac3268">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator const &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element, meaning if the initally allocated size if not big enough to hold all elements, then this method will simply not insert those elements instead. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class that points to the begin and end iterator of the given data container, allows for using / passing either std::vector or std::array. See <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">https://en.cppreference.com/w/cpp/iterator/input_iterator</a> for more information on the requirements of the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Attribute is not used and can be left as nullptr, simply there to keep compatibility with std::vector insert method </td></tr>
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to one past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a683e5ca9ab0b009eb1880fa20e7fca1e" name="a683e5ca9ab0b009eb1880fa20e7fca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683e5ca9ab0b009eb1880fa20e7fca1e">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c0d465703091b52d7ef1f51ab872be" name="aa9c0d465703091b52d7ef1f51ab872be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c0d465703091b52d7ef1f51ab872be">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f8a222828c457b826642c8faa7d8feb" name="a7f8a222828c457b826642c8faa7d8feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8a222828c457b826642c8faa7d8feb">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element at the end of the underlying data container, if the interal data structure is full already then this method will assert and stop the application. Because if we do not we could cause an out of bounds write, which could possibly overwrite other memory. Causing hard to debug issues, therefore this behaviour is not allowed in the first place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element that should be inserted at the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437f0f4218cf304a7bd3578a5b02bec3" name="a437f0f4218cf304a7bd3578a5b02bec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437f0f4218cf304a7bd3578a5b02bec3">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current amount of elements in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The amount of items currently in the underlying data container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
